<?xml version="1.0" encoding="iso-8859-1"?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xsl"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<!-- <?rfc private='my private memo'?>  Produce a private memo rather than a Xaraya-standard -->
<?rfc toc="yes"?>
<rfc number="0014" category="info">
	<front>
		<title>Modular Authentication System</title>
		<author initials="M." surname="Canini" fullname="Marco Canini">
			<organization>Xaraya Development Group</organization>
			<address>
				<email>unknown</email>
				<uri>http://www.xaraya.com</uri>
			</address>
		</author>
		<date month="March" year="2002"/>
		<!-- The abstract summarizes in one or two paragraphs the content of the RFC -->
		<abstract>
			<t>The contents of this RFC contain the literal content of the old plain
        text version of RFC-0014</t>
			<t>When time is a less scarcer good, someone might convert the plain text
        into structured XML so we can benefit from it.
      </t>
		</abstract>
	</front>
	<!-- The middle section is used for the actual content of the RFC -->
	<middle>
		<!-- One content section is mandatory -->
		<section title="Re-evaluation of this RFC">
			<t>
	Since this RFC was first written, Xaraya has gone through many changes, and thanks to the
	initial implementations of authsystem and authldap, it's time to re-evaluate some of the
	strengths and weaknesses of the initial design. Here are a few issues we noted :
			<list>
				<t>External authentication and external user data may be related
				in the sense that they both come from outside Xaraya, but there are
				many issues concerning retrieval, synchronisation or overriding of
				user data that do not apply to the "simple" action of authenticating
				a user at logon.</t>
				<t>Usage scenarios for combining different authentication methods
				and/or distributed user data are not well defined, with the result
				that design and implementation are limited to certain basic scenarios.</t>
				<t>At the moment (April 2003), only authenticate_user() is in active use,
				and this only for the login process. There is no link or verification during
				user registration.</t>
				<t>User data from external authentication sources is only used at login,
				in order to create a local user if one doesn't exist. There are no further
				queries, updates or synchronisation of external user data besides that at
				the moment.</t>
				<t>Current implementation in the auth* modules does not allow an
				easy centralised management of the different authentication methods, nor
				of any adequate handling of external user data.</t>
			</list>
			</t>
			<t>
	Some usage scenarios for authentication (to be expanded and evaluated) :
			<list>
				<t>local users, local authentication (obviously)</t>
				<t>local users, external authentication : i.e. at first login, a local user is
				created based on external user information (e.g. LDAP or non-Xaraya DB).
				Local user registration can be disabled via privileges (?)</t>
				<t>local users, multiple authentications (local or external) : potential conflict situations - who gets priority for (unique) username, or check against external auth at registration, or treat username+auth method as unique in the future, ...</t>
				<t>external users, external authentication : not supported at the moment - see below</t>
			</list>
			</t>
			<t>
	Some usage scenarios for user data (to be expanded and evaluated) :
			<list>
				<t>local user data (obviously)</t>
				<t>local user data, created once from external user data (e.g. LDAP or non-Xaraya DB)</t>
				<t>local user data, resynchronised from external user data at every login (or some other event)</t>
				<t>external user data, requested on demand - note : still a need for local core user fields</t>
				<t>external user data gets resynchronised from local user data on user update</t>
				<t>bi-directional synchronisation nightmare</t>
				<t>multiple sources of user data (local or external), with any or all of the above + possible overlap/overriding of one by the other</t>
			</list>
			</t>
			<t>
	To be continued...
			</t>
			<t>
	Note : add link with DD
			</t>
		</section>
		<section title="Introduction ">
			<t>
        Integration of older systems with new ones is a crucial point
        for success of systems, especially in the internet era. In main
        situations we can find heterogeneous services that can't
        cooperate because of their different authentication methods, and
        often implemented solutions are only wrappers or frontends to
        existing systems; in no way a definitive and universal
        solution. However in these years it's common practice to rely on
        well defined interfaces or portable libraries for getting a
        flexible and modular authentication system. To ensure Xaraya
        will be a high quality CMS we have to modularise authentication
        of users. This is definitely the purpose of MAS (Modular
        Authentication System).
			</t>
		</section>
		<section title="Modifications to current authentication API">
			<t>
        Currently the only official way to authorize user login is done
        by a set of functions in the Xaraya API. The default behavior of
        Xaraya will be to keep all registered users in the
        database. That is the current implementation. Modifications that
        will occure are:
        <list>
          <t>Migration of current authentication code in an authentication module.</t>
          <t>Reimplementation of user related API.</t>
          <t>
            Reimplementation of authorization info gathering
            function. Notwithstanding the introduction of a decentralised users
            database, to avoid user IDs duplications and espacially user data
            limitations, Xaraya will keep an entry for every user in the main
            database.
          </t>
        </list>
 			</t>
		</section>
		<section title="Authentication Modules">
			<t>
        The main idea is to use Xaraya modules API for implementing
        authentication modules. With the advent of Dynamic User Data,
        Xaraya will keep in the main database the part of user data that
        can't be handled by authentication module. A generic
        authentication module could override the user data present in
        database with other existing data (Think to LDAP authentication
        where many data already exists). The word override has to be
        intended as follow: premising that at current time the static
        users table coexists with the Dynamic User Data, if an
        authentication module can provide user data from other sources,
        the value stored in database will be ignored (overridden)
        whether it exists (has to in static table context) or not
        (optional user property in Dynamic User Data). The
        authentication module could implement an interface to create new
        users. The authentication module could implement an interface to
        delete users. The authentication module could override the
        permissions fetched from the database if it implements another
        interface.
			</t>
			<section title="Module Interfaces">
				<t>
          A generic authentication module must implement at least the
          Authentication interface. Other interfaces extend the
          exported module API and add new feautures to this
          module. Incarnation of interfaces is done by defining and
          implementing one or more module API functions (If you can't
          understand what is a module API function you're strongly
          encouraged to read the xarMDG documentation before
          proceding). The name of one authentication module API
          function, for its first part, is submitted to module API
          naming rules. The rest of the name is an underscore plus
          the interface method name. In this section are described
          all authentication interfaces currently supported by
          Xaraya.
        </t>
				<section title="Interface Authentication">
					<section title="Definition ">
						<t>
							<artwork>
                interface Authentication { 
                boolean authenticate_user($user_name, $user_password);
                boolean has_capability($capability);
                } 
              </artwork>
						</t>
					</section>
					<section title="Incarnation">
						<t>
              A generic authentication module ('authgen') MUST
              incarnate at least this interface. The incarnation
              for this interface is done by declaring and
              implementing the following methods:
            </t>
            <t>
              function authgen_userapi_authenticate_user($args) 
            </t>
            <t>
              <artwork>  
                This function will receive the following parameters:
                $args?'uname': user name
                $args?'pass': user password
              </artwork>
            </t>
            <t>
              This function MUST return a valid system user id IF and
              ONLY IF the user credentials are considered valid (the
              user is authenticated sucessfully) or _XARAUTH_FAILED
              for invalid credentials or false for bad parameters.
              Here is important to explain what a valid system user id
              is.  Xaraya keeps a reference to all system users
              notwithstanding they're authenticated by different
              authentication modules.  The section 5. User IDs mapping
              explains how to return a valid system user id.
            </t>
            <t>
              function authgen_userapi_has_capability($args) 
              This function will receive the following parameters:
            </t>
            <t>
              <artwork>  $args?'capability': the required capability, it's an identifier for another interface
                possible values are: _XARAUTH_USER_DATA_HANDLER
                _XARAUTH_PERMISSIONS_OVERRIDER
                _XARAUTH_USER_CREATEABLE
                _XARAUTH_USER_DELETEABLE
                _XARAUTH_USER_ENUMERABLE
              </artwork>
            </t>
            <t>
              This function MUST return true IF and ONLY IF the
              authentication module for wich it's written supports the
              required capability, false otherwise
            </t>
					</section>
				</section>
				<section title=" Interface ?DynamicUserDataHandler_Authentication">
					<section title="Definition">
						<t>
              <artwork>			              interface ?DynamicUserDataHandler_Authentication extends Authentication { 
                boolean is_valid_variable($variable_name);
                array get_user_variables($user_id);
                string get_user_variable($user_id, $variable_name, $property_id, $property_dtype);
                boolean set_user_variable($user_id, $variable_name, $variable_value, $property_id, $property_dtype);
                } 
              </artwork>
            </t>
					</section>
					<section title="Incarnation ">
						<t>
              The incarnation for this interface is done by declaring and implementing the following methods: 
            </t>
            <t>
              function authgen_userapi_is_valid_variable($args) 
            </t>
            <t>
              <artwork>
                This function will receive the following parameters:
                $args?'name': variable name
              </artwork>
            </t>
            <t>
              This function MUST return true IF and ONLY IF the
              authentication module can provide read and write
              operations for that variable, false otherwise.
            </t>
            <t>
              function authgen_userapi_get_user_variables($args) 
            </t>
            <t>
              <artwork>
                This function will receive the following parameters:
                $args?'uid': user id
              </artwork>
            </t>
            <t>
              <artwork> 
                This function MUST return all user variables
                handled by the authentication module as an associative
                array of pairs &lt;variable_name, variable_value&gt;, or
                false if it fails (remeber to set the errmsg session
                variable).
              </artwork>
            </t>
            <t>
              function authgen_userapi_get_user_variable($args) 
            </t>
            <t>
              <artwork>
                This function will receive the following parameters:
                $args?'uid': user id
                $args?'name': variable name
                $args?'prop_id': variable id in user_property table (probably you can get rid of that)
                $args?'prop_dtype': variable type as defined by Dynamic User Data types
              </artwork>
            </t>
            <t>
              This function MUST return the value of required user
              variable handled by the authentication module or false
              when this variable doesn't exist for that user or when
              it fails to fetch variable value (remeber to set the
              errmsg session variable).
            </t>
            <t>
              function authgen_userapi_set_user_variable($args) 
            </t>
            <t>
              <artwork>
                This function will receive the following parameters:
                $args?'uid': user id
                $args?'name': variable name
                $args?'value': new value to set to
                $args?'prop_id': variable id in user_property table (probably you can get rid of that)
                $args?'prop_dtype': variable type as defined by Dynamic User Data types
              </artwork>
            </t>
            <t>
              This function MUST return true if the oparation was
              concluded with success, false when it fails in the set
              operation or for other errors (eg: Bad params, No such
              connection to backend, ...).
            </t>
					</section>
				</section>
				<section title=" Interface ?PermissionsOverrider_Authentication ">
					<section title="Definition ">
						<t>
              <artwork>				interface ?PermissionsOverrider_Authentication extends Authentication { 
                array get_authorization_info($user_id);
                } 
              </artwork>
            </t>
					</section>
					<section title="Incarnation ">
						<t>
              TODO 
            </t>
					</section>
				</section>
				<section title="Interface ?UserEnumerable_Authentication">
					<section title="Definition ">
						<t>
              <artwork>
                interface ?UserEnumerable_Authentication extends Authentication { 
                array get_all_users();
                array get_user($user_id);
                } 
              </artwork>
            </t>
					</section>
					<section title="Incarnation ">
						<t>
              TODO
            </t>
					</section>
				</section>
				<section title=" Interface ?UserCreateable_Authentication">
					<section title="Definition ">
						<t><artwork>
                interface ?UserCreateable_Authentication extends Authentication { 
                boolean create_user($user_data);
                }
              </artwork>
            </t>
					</section>
					<section title="Incarnation ">
						<t>
              TODO 
            </t>
					</section>
				</section>
				<section title=" Interface ?UserDeleteable_Authentication ">
					<section title="Definition ">
						<t>
              <artwork>
                interface ?UserDeleteable_Authentication extends Authentication { 
                boolean delete_user($user_id);
                } 
              </artwork>
            </t>
					</section>
					<section title="Incarnation ">
						<t>
              TODO
            </t>
					</section>
				</section>
			</section>
			<section title="Naming conventions">
				<t>
          All authentication modules must respect the following naming conventions: 
          <list>
            <t>Module name MUST start with "Auth".</t>
            <t>Module directory MUST be all in lowercase and MUST begin with "auth". </t>
            <t>Module name SHOULD reflect as best as possible the authentication mechanism on wich it's based.</t>
          </list>
        </t>
			</section>
		</section>
		<section title="Authentication intersection">
			<t>
        The new authentication system will permit to use more than one
        authentication module. All modified User API will communicate
        with the correct authentication module.
			</t>
		</section>
		<section title="User IDs mapping">
			<t>
        The UserIDs module will be created to handle UIDs
        inconsistencies. This is a utility module for authentication
        modules. Its API permits to easily find correspondencies
        between different system UIDs. Basically it will use the
        database to store all mappings.
			</t>
		</section>
		<section title="Changelog ">
			<t>
        1.0 (April 14, 2003)
      </t>
      <t>
        Re-evaluation of the RFC
      </t>
			<t>
        0.9 (April 27, 2002)
      </t>
      <t>
        Cleaned the architecture, moved most of complexity to core system.
      </t>
      <t>
        Added Incarnation section to explain the obscure incarnation thing.
      </t>
      <t>
        Added a naming convention.
      </t>
      <t>
        0.12 (April 13, 2002)
      </t>
      <t>
        Added has_capabilty method to Authentication interface.
      </t>
      <t>
        Its purpose is to communicate to the core whether an auth module supports an interface.
      </t>
      <t>
        Added ?DeleteableUserData_Authentication for a better fine-grained control on user variables.
      </t>
      <t>
        Renamed ?PermissionOverrider_Authentication to ?PermissionsOverrider_Authentication.
      </t>
      <t>
        0.1 (March 28, 2002)
      </t>
      <t>
        Corrected ?ReadableUserData_Authentication and ?WriteableUserData_Authentication interfaces.
      </t>
      <t>
        Better description of user data override mechanism (I hope).
      </t>
      <t>
        Added Naming conventions section.
      </t>
      <t>
        RFC number set to 14.
      </t>
      <t>
        Removed some typos (Thanks to Gregor).
      </t>
      <t>
        Rearranged document layout (Thanks to Gregor).
      </t>
      <t>
        pre-0.1 (March 27, 2002)
      </t>
      <t>
        Initial Version by Marco Canini &lt;marco.canini@postnuke.com&gt;
			</t>
		</section>
	</middle>
</rfc>
