<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
<!ENTITY documentinfo SYSTEM "parts/document_info.xml">
<!ENTITY preface SYSTEM "parts/preface.xml">
<!ENTITY introduction SYSTEM "parts/introduction.xml">
<!ENTITY xaraya_module_architecture SYSTEM "parts/xaraya_module_architecture.xml">
<!ENTITY understanding_hooks SYSTEM "parts/understanding_hooks.xml">
<!ENTITY bibliography SYSTEM "parts/bibliography.xml">
<!ENTITY glossary SYSTEM "parts/glossary.xml">
]>
<book>
  <!-- Meta info about this document -->
  &documentinfo;

  <!-- Preface -->
  &preface;

  <!-- Introduction -->
  &introduction;

  <chapter>
    <title>Xaraya Architecture</title>

    <para>This chapter describes the basic architecture of Xaraya, explains
    the major parts, and contains information on the design choices made for
    the system. It describes how basic parts of Xaraya operate and what you
    can expect from Xaraya Core.</para>

    <section>
      <title>Block lay-out</title>

      <para>Explanation of Block Lay-out in Xaraya</para>
    </section>

    <section>
      <title>Xaraya API</title>

      <para>Reference type of text</para>
    </section>

    <section>
      <title>Core modules</title>

      <para>What Core modules are there, what can you use</para>
    </section>

    <section>
      <title>Blocks</title>

      <para></para>
    </section>

    <section>
      <title>Variable Handling</title>

      <para>Variables are loaded through xarVarFetch calls in order to be
      processed, checked for validity, as well as proper handling on unset
      vars, etc. Instead of relying on $_POST or $_GET calls throughout your
      module and then cleaning the input, Xaraya has a very robust way of
      handling the variable. You can process parameters in your function via
      the function itself as well. This is normally done by API functions, as
      parameters present in the environment can be different from the ones
      passed to these variables.</para>

      <para>An example call would be: <code>
          if (!xarVarFetch('itemsperpage', 'int', $itemsperpage, 10, XARVAR_NOT_REQUIRED)) return;
        </code></para>

      <para>This fetches the <varname>$itemsperpage</varname> variable from the input variable
      'itemsperpage' and validates it by applying the $validation rules, in
      this case it being an integer.</para>

      <para>The functions works in this order:</para>

      <para>First try to use the variable provided (itemsperpage), if this is
      not set (or the XARVAR_DONT_REUSE flag is used) then it tries to get the
      variable from the input (POST/GET methods for now). It then tries to
      validate the variable through xarVarValidate with the validation of
      'int' (integer).</para>

      <para>After the call the <varname>$value</varname> parameter is passed by reference is set
      to the variable value converted to the proper type according to the
      validation applied.</para>

      <para>The $defaultValue provides a default value that is returned when
      the variable is not present or doesn't validate correctly.</para>

      <para>
        The <varname>$flag</varname> parameter is a bitmask between the following
        constants:
        <itemizedlist>
          <listitem><para><constant>XARVAR_GET_OR_POST</constant></para></listitem>
          <listitem><para><constant>XARVAR_GET_ONLY</constant></para></listitem>
          <listitem><para><constant>XARVAR_POST_ONLY</constant></para></listitem>
          <listitem><para><constant>XARVAR_NOT_REQUIRED</constant></para></listitem>
        </itemizedlist>
        You can force to get the variable only from GET parameters or POST
        parameters by setting the <varname>$flag</varname> parameter
        to one of <constant>XARVAR_GET_ONLY</constant> or
        <constant>XARVAR_POST_ONLY</constant>.
      </para> 

      <para>
        You can force xarVarFetch not to reuse the variable by setting the
        <varname>$flag</varname> parameter to
        <constant>XARVAR_DONT_REUSE</constant>.
      </para>

      <para>By default $flag is XARVAR_GET_OR_POST which means that
      xarVarFetch will lookup both GET and POST parameters and that if the
      variable is not present or doesn't validate correctly an exception will
      be raised.</para>

      <para>
        The <varname>$prep</varname> flag will prepare <varname>$value</varname> by passing it to one of the
        following:
        <itemizedlist>
          <listitem><para><constant>XARVAR_PREP_FOR_NOTHING</constant>:
          no prep (default)</para></listitem>
          <listitem>
            <para>
              <constant>XARVAR_PREP_FOR_DISPLAY</constant>: 
              <function>xarVarPrepForDisplay(<varname>$value</varname>)</function>
            </para>
          </listitem>
          <listitem>
            <para>
              <constant>XARVAR_PREP_FOR_HTML</constant>:
              <function>xarVarPrepHTMLDisplay(<varname>$value</varname>)</function>
            </para>
          </listitem>
          <listitem>
            <para>
              <constant>XARVAR_PREP_TRIM</constant>:
              <function>trim(<varname>$value</varname>)</function>
            </para>
          </listitem>
        </itemizedlist>
      </para>

      <section>
        <title>Pitfalls with xarVarFetch()</title>

        <para>No error given</para>

        <para>Note that if a default value is specified, even if it is '', the
        function will always succeed. If you need to catch validation errors
        and other errors, you must set the default value to NULL.</para>

        <para>Loops with 1 $variable name</para>

        <para>If you have built a loop with this function in it, you will
        notice that the value of the first found instance is returned every
        single call, even though you may be calling for different named $_POST
        or $_GET elements. To solve this either use a variable variablename,
        or use the flag XARVAR_DONT_REUSE.</para>
        
        <example>
          <title>Fetching input variables</title>
          <programlisting>
            // If this is in your template/xhtml
            &lt;input name="item1" value=1&gt;
            &lt;input name="item2" value=2&gt;

            xarVarFetch('item1', 'str::', $value, NULL ) //  $value= 1

            xarVarFetch('item2', 'str::', $value, NULL ) //  $value= 1 !!!
          </programlisting>
        </example>

        <para>It is currently not possible to discern between 'Not Found' and
        'Validation Failed', if you need to know use the validate function and
        $_POST/$_GET directly in the error handling part.</para>
      </section>

      <section>
        <title>Module variables</title>

        <para>Module variables can be set using
        xarModSetVar('module','modulevariable','initial value')</para>

        <para>Example: <programlisting>xarModSetVar('julian','startDayOfWeek','1');</programlisting></para>

        <para>These variables can be called later by xarModGetVar(module,
        variable)<programlisting>$cal_sdow = xarModGetVar('julian','startDayOfWeek'); </programlisting>Now,
        we can even make this a variable the admin can set. Then add to the
        modifyconfig.xd template the following code snippet: <programlisting>&lt;input type="text" name="startDayOfWeek" value="#xarModGetVar('julian','startDayOfWeek')#" size="2" /&gt;</programlisting>
        and in your redirect script (updateconfig.php in the example module)
        <programlisting>//check the input with
xarVarFetch if (!xarVarFetch('bold', 'checkbox', $bold, false, XARVAR_NOT_REQUIRED)) return;
// Set the Module Variable:
xarModSetVar('example', 'bold', $bold); </programlisting>This lets the admin
        that can enter modifyconfig.xd set the variable by typing in a number
        for the variable 'startDayOfWeek', or 'bold' as in the example.</para>
      </section>
    </section>

    <section>
      <title>User Variables</title>

      <para>A user variable is an entity identified by a name that stores a
      value owned by exactly one user. Xaraya offers two API functions to
      manipulate user variables, they are xarUserGetVar() and xarUserSetVar().
      The purpose of xarUserGetVar() is to allow read access to one user
      variable. In contrast to that, xarUserSetVar() allows write access to
      one user variable. The $name parameter is checked against metadata to
      make sure the variable is registered. Xaraya keeps some metadata about
      every user variable, so you cannot access the $name user variable if its
      metadata is not registered.</para>

      <para>A module can register a new user variable by providing its
      metadata only if it has the right permissions (permissions are checked
      by the registration function). Usually the registration process should
      take place at initialization time for a module that wants to use the
      $name user variable during its life cycle. Xaraya does not impose any
      restriction on the value of $name except for duplicate and reserved
      names.</para>

      <para>
        As of this writing, the list of reserved names consists of:
        <itemizedlist>
          <listitem><para><constant>uid</constant> The user id.</para></listitem>
          <listitem>
            <para><constant>name</constant> The user display name on the system.
            “Name” should be used in any case that you are displaying the user
            name, IE author fields, etc.</para>
          </listitem>
          <listitem>
            <para><constant>uname</constant> The user name is the system
            variable used to differentiate one user from another in string vice
            integer format. This variable should not be used to display
            information about the user for consistency and security
            reasons.</para>
          </listitem>
          <listitem>
            <para><constant>email</constant> The email address of the
            user.</para>
          </listitem>
          <listitem>
            <para><constant>status</constant> The status of the user (active,
            inactive, deleted etc).</para>
          </listitem>
          <listitem>
            <para><constant>auth_module</constant> The authentication module
            last used for this user.</para>
          </listitem>
        </itemizedlist>
      </para>

      <para>You are advised (even for performance reasons) to use the
      following naming convention: <programlisting>$name := $module_name . '_' .
      $real_name</programlisting></para>

      <para>To register the $name user variable you have to use the module API
      function register_user_var() exported by the Modules module.</para>

      <para>Here is an example: <programlisting>
        $module_name = 'MyModule';

        $variable_name = 'MaxLinesPerPage';

        $metadata['label'] = $module_name . '_' . $variable_name;

        $metadata['dtype'] = _UDCONST_INTEGER; //one of the values  defined for dynamic user data variable types

        $metadata['default'] = 20; $metadata['validation'] = 'num:&gt;=:10&amp;num:&lt;=:100';

        xarModAPILoad('Modules', 'admin');

        $result = xarModAPIFunc('Modules', 'admin','register_user_var', $metadata);

        if (!isset($result)) {
            // xarModAPIFunc() failed
        } elseif ($result == false) {
            // registration failed
        } else {
            // registration succeeded
        }
        </programlisting></para>

      <para>As you can see in this example, a descriptive array for the new
      user variable is created first, and later register_user_var is called
      with that array as parameter. Meaningful keys for the array are label,
      dtype, default and validation. The label field is mandatory; it
      specifies the user variable name as you'll refer later in
      xarUserGetVar() and xarUserSetVar() $name parameter. The dtype field is
      mandatory; it can take one of the following values: _UDCONST_STRING,
      _UDCONST_TEXT, _UDCONST_FLOAT, _UDCONST_INTEGER. You should obviously
      choose the right value for the data type that the new user variable
      would contain. The default field is optional; Used when the user has not
      yet set a value for the new user variable. The validation field is
      optional; refer to the next section to get an overview of variable
      validation. To unregister a user variable you have to call the
      unregister_user_var(), which is located in the users module admin API.
      You should call that API only at uninstallation time for your modules.
      Keep in mind that by calling unregister_user_var() all the existing
      values for that user variable will be deleted from user data. As
      described in this document, Xaraya offers support for module variables
      too. If you get confused from that, and cannot see the distinction
      between these different things, here is a little explanation. Module
      variables are system-wide variables, shared between each module user,
      like configuration variables. No particular user owns them, and even if
      they do they are protected by permissions for write access, they are
      typically administrative-side variables. You are encouraged to use them
      when you have a need to give administrators the possibility to choose
      some behaviors of your module. However, when those behaviors are related
      to user preferences you should avoid using module variables and register
      a new user variable to be used in your code.</para>

      <para>As an example, you can consider the above code listing, where a
      new user variable is registered to allow every single module user to
      choose his own MaxLinePerPage setting. Now it is reasonable to have
      selected this choice, but here we could have chosen a unique shared
      module var as well. On the other hand, you do not have this kind of
      freedom, for example consider the authldap module in some cases. It
      needs to access a LDAP server, so it needs a variable that contains the
      LDAP server hostname. Obviously this variable should be a module
      variable, and access to it should be granted only to administrators with
      the right permissions. We invite you to ponder this issue for a while
      before you settle on module vars or user vars.</para>

      <para>Setting xarUserVars</para>

      <para>All user vars should be set from adding Dynamic Data on the roles
      module. This will give you the greatest benefit and will present the
      variables to all modules on the system.</para>
    </section>

    <section>
      <title>Error handling</title>

      <para>Xaraya is capable of error handling through a powerful exception
      handling system. Since the PHP language does not support language-level
      exceptions, Xaraya provides an artificial mechanism to deal with
      exceptions. Xaraya divides exceptions into two types: system exceptions
      and user exceptions. System exceptions are used by Xaraya API functions,
      but you can use them if it's meaningful in that such situation; for
      example consider the DATABASE_ERROR exception, you are strongly
      encouraged to use this exception when a database error occurs and not to
      use your own exception.</para>

      <para>As another example considers the BAD_PARAM exception, you should
      choose to use that exception in your module functions and API functions
      when passed parameters are wrong. Finally, system exceptions are well
      known exceptions for which Xaraya can undertake. Xaraya does not know
      particular actions like logging, emailing, or user exceptions, and since
      they are indistinguishable, Xaraya will treat them, as they were all the
      same thing.</para>

      <para>Another good point of distinction between system and user
      exceptions is the fact that you should not leave uncaught user
      exceptions as you can do for system exceptions. Hence, you should catch
      all user exceptions instead of throwing them back to Xaraya, this is
      because user exceptions are the same as soft exceptions, so you could be
      in the position of doing other actions and/or returning a properly
      formatted error message that will look better than the default Xaraya
      exception caught error message. However, it is not illegal to throw back
      user exceptions to Xaraya, so fell free to do that if it is the
      case.</para>

      <para>You should avoid catching system exceptions, except in particular
      cases. A system exception is a hard exception, this means that something
      very wrong happened and Xaraya should be notified. You can achieve this
      simply by throwing back system exceptions. In addition, there are
      particular circumstances in which you could and perhaps should catch
      system exceptions.</para>

      <para>For example consider the xarUserGetVar() API function: it raises a
      NO_PERMISSION system exception in the case you don't have right
      permission, however you weren't in the position to get access level for
      user variables, so it's perfectly acceptable here to catch this
      exception and go ahead when it's meaningful to do so.</para>

      <para>Now is the moment to explore how Xaraya permits you to deal with
      exceptions. Here we begin by exposing how to catch exceptions. When a
      function that potentially can raise exceptions, outcomes with a void
      value you MUST check if some exception was raised. You can do that by
      calling the xarExceptionMajor() function and comparing its return value
      with the <constant>XAR_NO_EXCEPTION</constant> constant. If they are different, you know that
      an exception has been raised.</para>

      <para>The xarExceptionMajor() return value can assume one of these
      values: <constant>XAR_NO_EXCEPTION</constant>, <constant>XAR_USER_EXCEPTION</constant>, <constant>XAR_SYSTEM_EXCEPTION</constant>. The
      value <constant>XAR_NO_EXCEPTION</constant> indicates that no exception was raised, and
      <constant>XAR_USER_EXCEPTION</constant> stands for user exception was raised and
      <constant>XAR_SYSTEM_EXCEPTION</constant> stands for system exception was raised.</para>

      <para>When you see that an exception was raised you have two options:
      throw it back or handle it. To throw back an exception you have only to
      return with a void value. To handle an exception you have to check for
      the exception type, id and value if one.</para>

      <para>Consider the following example:</para>

      <para><programlisting>
          $res = xarModFunc('MyModule', 'user','MyFunc');
          if (!isset($res) &amp;&amp; xarExceptionMajor() != XAR_NO_EXCEPTION) {
              // Got an exception if (xarExcepionMajor() == XAR_SYSTEM_EXCEPTION) { return; // throw back }

              // Got a user exception
              if (xarExceptionId() == 'MyException1') {
                  $value = xarExceptionValue();

                  $output-&gt;Text("Syntax error at line: ".$value-&gt;lineNumber);

              } elseif (xarExceptionId() == 'MyException2') {
                  /* Do something useful */
              } else { // MyException3
                  /* Do something useful */
              } // reset exception status

              // NOTE: it's of vital importance to call this function
              // before returning xarExceptionFree();

              return $output-&gt;GetOutput();
          }
        </programlisting></para>

      <para>To throw exception you use a unique function: xarExceptionSet().
      You simply call it by passing the exception major, id and value if one;
      and after this call, you return void.</para>

      <para>Consider the following example:</para>

      <para><programlisting>class MyException1
{
    var $lineNumber;
}
/* ... */
MyModule_user_MyFunc()
{
    /* ... */
    if ($syntax == false) { // Syntax error
        $exc = new MyException1;
        $exc-&gt;lineNumber = $line;
        xarExceptionSet(XAR_USER_EXCEPTION, 'MyException1', $exc);
        return;
    }
    /* ... */
    xarExceptionSet(XAR_USER_EXCEPTION, 'MyException2');
    /* ... */
    xarExceptionSet(XAR_USER_EXCEPTION, 'MyException3');
    /* ... */
    return true;
}</programlisting></para>

      <para>Note that no value is associated to MyException2 and MyException3,
      so there is no need to create a class for exception value. As you can
      see exception, handling is very powerful but also boring and tedious.
      However, you can always choose not to use user exceptions and always
      throw back system exceptions.</para>

      <para>Keep in mind that good error handling is not something that to
      leave for last. It should be part of the development process. Note that
      it is wrong not to check exception status after a call to a function
      that can potentially raise something. And note also that if you choose
      to handle one or more exceptions you MUST call xarExceptionFree() before
      exiting, otherwise the trust relationship on which the exception
      handling mechanism is based won't work and you will produce very bad
      things.</para>

      <para>An ulterior thing for those of you wanting to code an official
      Xaraya module: you MUST always check for possibly raised exceptions and
      not code with the thought that something will never happen; you MUST
      also raise DATABASE_ERROR in every function that does queries. To get a
      better understanding of exception handling functions you should refer to
      the Xaraya API Command Reference.</para>
    </section>

    <section>
      <title>Itemtypes</title>

      <para>Itemtypes definitions are crucial in Xaraya operations. Itemtypes
      are very important when ever your data is shared with either hooks or by
      other modules.</para>

      <para>Related functions</para>

      <para>-getitemtypes</para>

      <para>-getitemlinks</para>
    </section>

    <section>
      <title>Interaction with core classes</title>

      <para>The interaction with core functions, what to rely on and how to
      access these functions</para>
    </section>

    <section>
      <title>Multilanguage system</title>

      <para>Xaraya can be fully multilanguage. Make sure all your text strings
      are encapsulated with either <programlisting>xarML('YourMLString') </programlisting>in
      your functions or <programlisting>&lt;xar:mlstring&gt;YourMLString&lt;/xar:mlstring&gt;</programlisting>
      in the templates</para>
    </section>

    <section>
      <title>Variable preparations</title>

      <para><programlisting>xarVarPrepForDisplay(YourString);</programlisting></para>
    </section>

    <section>
      <title>Dynamic Data</title>

      <para>Properties</para>

      <para>Your own properties</para>
    </section>
  </chapter>

  <!-- Module architecture -->
  &xaraya_module_architecture;


  <chapter>
    <title>Xaraya Module Operations</title>

    <para>This chapter covers how modules interact with Xaraya. The
    information in this section is correct for the 1.0 release of Xaraya, for
    other releases please get the most recent copy of the Xaraya Module
    Developers Guide.</para>

    <section>
      <title>Locating Modules</title>

      <para>All Xaraya modules must be placed within their own subdirectory of
      the 'modules' directory to be recognized. Modules placed anywhere else
      within the file-system will not be located correctly.</para>
    </section>

    <section>
      <title>Working out Module Functionality</title>

      <para>A module might have administration or user functionality, or both.
      Xaraya works out which functionality each module has by looking for the
      files in 'xaradmin' or 'xaradminapi’ directories to confirm
      administration functionality, and in 'xaruser' or 'xaruserapi'
      directories to confirm user functionality. Lack of these directories
      results in Xaraya assuming that this specific module functionality does
      not exist.</para>
    </section>

    <section>
      <title>Initializing Modules</title>

      <para>Initialization of modules is accomplished through the
      modname_init() in the 'xarinit.php' file within the module's directory
      function. No other functions are called when the module is initialized.
      All initialisation routines should go into the init function.</para>
    </section>

    <section>
      <title>Activating/Deactivating Modules</title>

      <para>Activation and deactivation of modules is accomplished through
      field settings within the appropriate database table. Unlike earlier
      versions of Xaraya, no physical changes to the module directories are
      made to infer the activation status of the module.</para>
    </section>

    <section>
      <title>Upgrading your module</title>

      <para>Upgrading your module is important. The upgrade function is
      located in the xarinit.php and named yourmodule_upgrade(). This function
      takes the current versionnumber as 'oldversion' and uses a switch to
      look for the correct upgrade routines. Make sure you provide all
      necessary steps for each version to upgrade to the next version. Provide
      an empty upgrade step when there is nothing todo. This way, the upgrade
      function will stay consistent. The versionid is set in the
      xarversion.php file.</para>
    </section>

    <section>
      <title>Calling Module Functions</title>

      <para>Module functions are called through the xarModFunc() and
      xarModAPIFunc() functions. No direct calling of module functions is
      allowed, even from within the same module. Creating Module URLs Direct
      URLs to functions URLs for modules go through the 'index.php' entry
      point, and are defined by a number of parameters. The parameters that
      currently decide which particular module function to call are as
      follows: module The name of the module. This corresponds to the
      well-known name of the module, which can be found through the modules
      administration interface type The type of the module function. This is
      currently either 'user' for user functions or 'admin' for administrative
      functions. func The name of the function itself. This is
      module-dependent. If any of these parameters are undefined within a URL
      Xaraya will apply defaults to them. Note that both the names of the
      parameters and their default values might change, and as such it is not
      recommended to create direct URLs for anything but to either go through
      the Xaraya main page or to use the xarModURL() function to generate URLs
      that will always be internally consistent for any given version of
      Xaraya. You can also extend the xarModUrl call by adding a parameter
      call to the function in the form of an array. <programlisting><function>xarModURL('<parameter>module</parameter>', 'type', 'function', array('foo' =&gt; $bar))</function></programlisting>
      will create the input parameter of 'foo' having the value of
      $bar.</para>

      <section>
        <title>Function calls</title>

        <para>Another way of accessing the functionality of other modules is
        by calling their functions directly with the xarModFunc() function.
        Doing this allows a number of advantages over hooks, but also a number
        of disadvantages. In general, calling functions directly is more
        flexible as the module developer understands exactly which functions
        they are calling and can pass additional arguments to the function to
        customize its abilities. The disadvantages are that the module named
        in the function call needs to be installed and active on the system
        for the calls to work, and if this is replace by a different module
        providing similar functionality it will not work correctly.</para>

        <para>Using direct function calls to other modules is fine within a
        module, but the developer should consider the implications of this on
        systems that might not have the modules that they are using installed.
        Also, even if direct function calls are used then the module developer
        should still call hooks at the appropriate places in the code to allow
        for other extended functionality to be added to the module.</para>

        <para>An example of where direct function calls might be used within
        the Example module would be if the module developer wanted users to be
        able to rate various aspects of the picture displayed such as 'use of
        color' and 'originality'. In this case, a simple hook would not be
        able to accommodate this requirement, so the developer would instead
        make explicit calls to the 'Ratings' utility module to display a
        number of separate ratings, each with its own identifier. The hook
        call would still be made, which might also add a rating to the
        picture, but in this case, the value could be considered as the
        overall rating for the picture rather than that just for a specific
        part.</para>
      </section>
    </section>

  </chapter>

  <!-- Hooks -->
  &understanding_hooks;


  <chapter>
    <title>Writing your module</title>

    <para>This Chapter can be the reference to how to setup your module
    design</para>

    <section>
      <title>Before Starting Your Module</title>

      <para>There are a number of steps to follow before you can start
      building your module.</para>

      <para>Choosing a Name for Your Module</para>

      <para>Choosing a name for your module is important, as this is the main
      way that your module will be known throughout the Xaraya community. The
      name should relate to the functionality that the module provides, but
      also be specific enough to be able to discern it from separate modules
      that might offer similar functionality. Module names are case-sensitive.
      All modules names are lower-case only.</para>

      <para>Decide on the Type of Your Module</para>

      <para>There are two broad types of module available in Xaraya. Item
      modules are modules, which contain their own content and operate on that
      content, whereas utility modules are modules, which contain additional
      information or functionality for the content of other modules. Examples
      of item modules are news, FAQ, and download. Examples of utility modules
      are comments, ratings, and global index. Either utility modules work in
      the same way as item modules, or they can operate with hooks, which
      allow module functions to be acted upon without being explicitly called
      by other modules. Hooks are used for items that are not part of a piece
      of content but directly related to it.</para>

      <para>Register Your Module Name</para>

      <para>Registering your module is not compulsory, but it is a very good
      idea. By registering your module, you can ensure that no other official
      Xaraya module will take the name that you have chosen for your module.
      Two modules with the same name will not operate correctly on a single
      Xaraya site, so it is beneficial to both yourself and the Xaraya
      community in general to have a unique name. You may register your module
      via the release module on <ulink url="???">http://www.xaraya.com/
      </ulink></para>

      <para>Obtain a Copy of the Xaraya API Reference Guide</para>

      <para>The Xaraya API Reference Guide has been moved to the PHP-Doc style
      of documentation. No separate entry will be created for the API guide.
      Please reference http://docs.xaraya.com/index.php/documentation/c80/ for
      more information.</para>

      <para>Read the Notes on Developing Modules Section</para>

      <para>The section entitled 'Notes on Developing Modules' includes a lot
      of miscellaneous information that does not fit in other sections of this
      document. It should be read fully before any attempt to design or
      develop a module is started.</para>

      <para>Understand the Following Areas</para>

      <para>Difference between GUI and Operational Functions</para>

      <para>Understanding the difference between GUI and operational functions
      is critical when building a good module. Proper separation of these
      functions will allow other modules to be able to access the
      functionality of your module and incorporate it into their modules. It
      will also allow methods of access apart from those that the standard
      web-based Xaraya system.</para>

      <para>Difference between User and Administrative Functions</para>

      <para>Understanding the difference between user and administrative
      functions is very important when building a good module. The separation
      of these types of actions allows for the Xaraya Security Model The
      Xaraya security model is a very important area to understand before
      coding a module. Developers should understand which parts of their
      module need protected, and exactly how this is accomplished. The entire
      Xaraya security model is beyond the scope of this document. The Security
      System RFC30 is located at
      http://docs.xaraya.com//docs/rfcs/rfc0030.html</para>

      <para>Function Return Codes</para>

      <para>Every well-defined module function must return the appropriate
      return codes. Return codes are the main way in which a module
      communicates with the Xaraya core, and as such, it is vital that the
      correct return codes are used. The following return codes should be used
      when returning control to the Xaraya core from any module
      function:</para>

      <para>string</para>

      <para>Returning a text string implies that the modules function has
      finished its work and has output to be displayed in the appropriate
      place on the Xaraya web page. Xaraya will take the returned output and
      display it as appropriate. Note that all output from modules is
      displayed verbatim, with no escaping of HTML characters. This is to
      allow for formatted output from the module functions.</para>

      <para>true</para>

      <para>Returning boolean true implies that the module function has
      finished its work and set up an appropriate redirect to send the user to
      a page that will have display output. The Xaraya core will take no
      further action as far as this module is concerned.</para>

      <para>false</para>

      <para>Returning boolean false implies that the module function has
      finished its work but not set up an appropriate redirect to send the
      user to a page that will have display output. The Xaraya core will set
      an appropriate redirect for this module. Note that none of these
      functions carries any information about the success or failure of the
      attempted operation that the module function was undertaking.</para>

      <para>array</para>

      <para>The array can contain the parameters that you need to return to
      the Xaraya core</para>

      <para>Where Modules Fit in Xaraya</para>

      <para>Modules cover two separate areas of Xaraya. The first is
      administration of core functions, (e.g. users, permissions), and the
      second is extension of system functionality (e.g. downloads, web links).
      As each of these areas is not core this implies two things. First is
      that no module is actually required - the Xaraya system would work
      without anything in its modules directory, although its functionality
      would be severely limited and there would be no configuration options
      available. Second, is that modules should not remove any core
      functionality when installed, in operation, or removed.</para>
    </section>

    <section>
      <title>Design Your Module</title>

      <para>An often-overlooked point is that the module should be designed
      before being coded. This will allow for far easier coding later on, and
      an understanding of how the module fits into the generic Xaraya module
      structure. Some of the points that should be considered are: What data
      does the module store? How should the module data best be stored? Is the
      data hierarchical or flat? What does the module do with the stored data?
      How is the data displayed, how much data is displayed at any one time?
      What options should the user have to view the data in different ways?
      How does the module interact with other modules? Does it compete
      directly with other modules? If so, does it make sense to follow their
      module API to allow for greater interoperability between similar
      modules? Can it use other modules for part of its functionality? Is it
      better written as an extension to a current module rather than starting
      again from scratch? Consider Including the Standard Module Functions
      There are a number of standard module functions that allow a module to
      interface with parts of the Xaraya system. These functions have
      predefined inputs and outputs, allowing external modules and core
      functions to use them effectively without needing to tailor their
      operation to each separate module. The best example of these functions
      is the 'search' function, which passes in a simple text string and
      requires that an array is passed back about all items within the module
      that match the string. If your module does not have these functions then
      it will not integrate fully with the other parts of the Xaraya system.
      It is recommended that these functions be supplied if they make any
      sense in the context of your module. Use Standard Function Names There
      are a number of function names that are considered standard i.e. they
      have well-known meanings and are used in a number of modules. Using the
      standard function names makes it easier for other module developers to
      use your module. Some of the standard functions are shown below. The
      list below is subject to addition as more functions that are standard
      are introduced - the example module supplied with your copy of Xaraya
      should have the most up-to-date set of standard functions available.
      User Display Functions main() - the default function to call, normally
      just presents the user menu view() - display an overview of all items,
      normally paged output display() - display a single item in detail, given
      an identifier for that item User API Functions getall() - get basic
      information on all items, can take optional parameters to obtain a
      subset of all items get() - get detailed information on a specific item
      Administration Display Functions main() - the default function to call,
      normally just presents the user menu view() - display an overview of all
      items, normally paged output, with relevant administrative options. Note
      that it is possible to combine this function with the user view()
      function new() - display a form to obtain enough information from the
      user to create a new item create() - take the information from the form
      displayed by the administration new() function and pass it on to the
      administration API for creating the item modify() - display the details
      of a current item given the item description, and present the relevant
      fields for modification update() - take the information from the form
      displayed by the administration modify() function and pass it on to the
      administration API for modifying the item delete() - display
      confirmation for deletion of an item, and if confirmed pass the relevant
      information on to the administration API for deleting the item
      modifyconfig() - display the details of the module's current
      configuration, and present the relevant fields for modification
      updateconfig() - take the information from the form displayed by the
      administration modifyconfig() function and update the relevant module
      configuration variables Administration API Functions create() - create a
      new item delete() - delete a current item update() - update the
      information about a current item Find out What Utility Modules are
      Available There are a number of utility modules available to carry out
      features that are required by many item modules within Xaraya. Examples
      of available utility modules are comments, ratings, and categorization.
      Look at xaraya.com to find out what other utility modules are available
      and if they can be used in lieu of parts of the code that you would
      otherwise be writing for your own module.</para>
    </section>

    <section>
      <title>Building Your Module</title>

      <para>This section is a short manual how to write your own module. If
      you are developing a module for the first time, it is recommended to
      follow these steps.</para>

      <section>
        <title>Make Your Initial Directory</title>

        <para>Create the directory to hold the module files. This directory
        must be created under the 'modules' directory in the Xaraya install,
        and must be created with the name of your module as registered at the
        Xaraya modules site.</para>

        <para>Copy the Module Example Copy over all of the files from the
        example module directory into you newly created module directory.
        These files set up the basic structure for your module and allow you
        to get to work creating your module very quickly.</para>
      </section>

      <section>
        <title>Code your Database Tables</title>

        <para>Coding your database tables requires you to edit the
        xartables.php file in your module directory. This file gives
        information on the structure of the tables used by this module,
        although it does not carry out any actions itself. The structure
        information is wrapped in a function (modname_xartables()) for easy
        access by the Xaraya system. An annotated copy of the template
        xartables.php file is available in the standard Xaraya distribution as
        part of the Template module.</para>

        <para>If your module uses tables specified by another module then you
        can either remove the xartables.php file completely from your module
        directory, or have a suitably named function that just returns an
        empty array. If you attempt to use the same table name as another
        module or the Xaraya core then your module will fail in unexpected
        ways. Try to give your tables unique names, preferably based on your
        module name.</para>
      </section>

      <section>
        <title>Write your Initialization Functions</title>

        <para>Module initialization functions are required for three separate
        actions. These actions are initialization of the module's tables and
        configuration, upgrade of the module's tables and configuration, and
        deletion of the module's tables and configuration. Each of these items
        are generally only called once, although if a site administrator
        desires they should be able to initialize and delete a module as many
        times as they wish. It should be assumed that whenever these functions
        are called the Xaraya system has already loaded the relevant
        information from xartables.php and it is available in the information
        returned by xarDBGetTables(). An annotated copy of the template
        xarinit.php file is available in the standard Xaraya distribution as
        part of the Example solution.</para>

        <para>Test Your Initialization Routines</para>

        <para>Once the database structure and initialization files are in
        place they should be tested by using the modules administration area
        of your Xaraya system to test initializing and deleting your module.
        You should manually check that the database table created is correct,
        and that deleting a module removes all of the relevant configuration
        variables and database tables. Once you are happy that the module
        initialization functions are working correctly you should carry out an
        initialization so that work on the administration and user functions
        can proceed with suitable database tables in place.</para>

        <para>Write Your Administration Functions</para>

        <para>With your database tables in place, the next step is to write
        some administration functions. The administration functions that you
        will write depend on the nature of your module, however most modules
        have at least the following items: add a new item modify an existing
        item delete an existing item Each of these items is normally broken
        down into three separate pieces. The first piece is part of the GUI
        and displays a form with suitable fields for user input. The second
        piece is part of the API and carries out the requested operation. The
        third piece is another part of the GUI, gathers information from the
        form displayed by the first piece, and passes it as arguments to the
        second piece. As mentioned earlier in the document, it is vital that
        the separation between the GUI and API functions is clear. If you are
        unsure about whether part of a function should be in the GUI or the
        API, look at what it does. If it is directly involved with user
        interaction (gathering information from the user or displaying
        information to the user) then it is a GUI function. If it is involved
        with obtaining or updating information in the Xaraya system itself
        (normally in a database table) then it is an API function. Annotated
        copies of the template xaruser and xaruserapi function files are
        available in the standard Xaraya distribution as part of the Example
        module.</para>

        <para>Test Your Administration Functions</para>

        <para>Once the administration functions are in place, they need
        testing by using the administration area of your module to carry out
        the basic functionality that you have created. The operation of the
        module functions need checking against the information in the database
        to ensure that they are storing and displaying the data
        correctly.</para>

        <para>Write Your User Functions</para>

        <para>Once the administration functions are in place to manipulate
        your module's data then you can write the user functions to display
        the data. As with the administration functions the user functions that
        you will write depend on the nature of your module, however most
        modules have at least the following items: overview of a number of
        items detailed view of a single item Each of these items is normally
        broken down into two separate pieces. The first piece is part of the
        GUI and gathers information from the user as to which item they wish
        to view, passes it on to the API piece, and displays the resultant
        information. The second piece is part of the API and obtains the
        required information for the display piece. Annotated copies of the
        template xaruser and xaruserapi function files are available in the
        standard Xaraya distribution as part of the Example module.</para>

        <para>Test Your User Functions</para>

        <para>Once the user functions are in place they need testing by
        operating the module in the same way that a normal user would. The
        operation of the module functions need checking against the
        information in the database to ensure that they are displaying the
        data correctly.</para>

        <para>Write Your Blocks</para>

        <para>You might want your module to include blocks. Blocks are smaller
        functional units of a module that display specific information, and
        generally show up down the left and right hand sides of a page. Blocks
        are relatively simplistic items, and can either use their module's API
        functions to obtain information or use their own direct SQL query.
        Although they are packaged as part of the module they are not directly
        related to it except that they use the same database tables, and as
        such they might have to load the module's database table information
        directly through the use of the xarModDBInfoLoad() function if they
        intend to access the module's tables directly. An annotated copy of
        the template first.php block is available in the standard Xaraya
        distribution as part of the Example module.</para>

        <para>Test Your Blocks</para>

        <para>Once the blocks are in place, they need testing by displaying
        them through the Blocks administration system. The blocks need
        checking against the database and the user functions to ensure that
        they are displaying the data correctly.</para>

        <para>Document Your Module</para>

        <para>Documenting your module is a vital step. There are two areas
        your module needs documentation: user information and API information.
        The first area is covered by producing a manual and placing it in the
        appropriate place in the directory hierarchy. The second area by
        writing a short description of each API function, noting the
        parameters and return values that it has, and placing that at the head
        of the function. Coding the documentation in the style of PHPDoc will
        allow for automatic parsing of the documentation by other developers
        who wish to use your module.</para>

        <para>Packaging Your Module</para>

        <para>At this stage, the module should be ready for packaging. The two
        most widely used packaging formats are WinZip (.zip extension) and
        compressed TAR (.tar.gz extension). If possible, package the module
        with both formats. If not then just, package it with the format that
        you have and ask on the Xaraya site if someone can package it in the
        other format.</para>

        <para>Interacting With Other Modules</para>

        <para>Overview</para>

        <para>When designing your module you may well find there is
        functionality that you require in a module already available. Utility
        modules are designed specifically to provide additional often-used
        functionality for modules in a standard way, and sometimes the
        functionality of an entire module might be used as part of your
        module. Functionality can be obtained either from the display part of
        the module or the API itself, depending on the specific requirements
        in the new module. Interaction with other modules is carried out in
        different ways depending on the type of module being written and the
        level of specific control the module requires over the function being
        called.</para>
      </section>
    </section>
  </chapter>

  <chapter>
    <title>Notes in Developing Modules</title>

    <para>xarAPI is the Xaraya Application Programming Interface, a way for
    modules to interact with the Xaraya core without needing to access tables
    and internal structures directly. The API also allows for the underlying
    implementation details of Xaraya to be hidden from developer so that they
    can write modules in a standard fashion and not worry about what might
    change under the hood. This is very important for a system such as Xaraya,
    which has undergone, and continues to undergo, radical changes in the core
    design to allow it to be faster, more secure, and more flexible. xarAPI is
    the only supported way of accessing core information. Module developers
    must use these methods of obtaining information from the Xaraya core
    system; failure to do so will very likely result in their module not
    working when the next version of Xaraya is released.</para>

    <section>
      <title>Security</title>

      <para>Security is a very important part of Xaraya. All modules should
      subscribe to the Xaraya Security model to ensure that they operate
      correctly within all environments. For full information on security
      refer to the Xaraya Security Model documentation, however the main
      points as regards modules are covered briefly below. Variable Handling
      All variables that come in to or go out of Xaraya should be handled by
      the relevant xarVar*() functions to ensure that they are safe. Failure
      to do this could result in opening security holes at the web,
      file-system, display, or the database layers. Full information on these
      functions is in the Xaraya API Guide, and examples of their use are
      shown throughout the example module. It can be assumed that any
      variables passed to functions in the Xaraya API will be handled
      correctly, and as such these variables do not need to be prepared with
      the xarVar*() functions.</para>
    </section>

    <section>
      <title>Authorization</title>

      <para>All items displayed for users and actions carried out by
      administrators must be authorized through use of the xarSecAuthAction()
      function. This function underlies the entire Xaraya permissions system
      and as such must be used wherever an access check is required.</para>
    </section>

    <section>
      <title>Reserved Variable Names</title>

      <para>Xaraya has a number of variables, which are reserved. These
      variables are not be used within modules as they can conflict with the
      Xaraya core and cause unpredictable results. The current lists of
      variables, which are reserved, are as follows:</para>

      <itemizedlist>
        <listitem>
          <para>file</para>

          <para>the file to open</para>
        </listitem>

        <listitem>
          <para>func</para>

          <para>In use for Function, the function being called</para>
        </listitem>

        <listitem>
          <para>loadedmod</para>

          <para>The module that is loaded. Mainly in use by the core module
          'roles'</para>
        </listitem>

        <listitem>
          <para>module</para>

          <para>The module that is being called</para>
        </listitem>

        <listitem>
          <para>name</para>
        </listitem>

        <listitem>
          <para>op</para>
        </listitem>

        <listitem>
          <para>pagerstart</para>
        </listitem>

        <listitem>
          <para>pagertotal</para>
        </listitem>

        <listitem>
          <para>type</para>

          <para>Either user or admin, type of function to call</para>
        </listitem>
      </itemizedlist>

      <para>In addition, all one-letter variables are reserved.</para>
    </section>

    <section>
      <title>Page Path</title>

      <para>All input from web pages goes through a two-stage process. The
      first part is displaying the information entered in a form, and the
      second is obtaining that information and passing it on to the module
      API. In addition to the visible information, there are often a number of
      hidden items of information in the first page that is used in the second
      page. To ensure that any attempt to add, delete, or change information
      in the Xaraya system goes through the full two-stage method of gathering
      and processing the information the two functions xarSecGenAuthKey() and
      xarSecConfirmAuthKey() must be used in the appropriate places. The
      Example module in the standard Xaraya distribution contains a number of
      functions that use these API calls, and note where they are used so that
      developed modules will have the same level of protection against
      fraudulent administrator requests.</para>
    </section>

    <section>
      <title>Output</title>

      <para>All output generated by module functions must be returned to the
      Xaraya core. No output of any type pushed directly from the module; this
      is not supported and will break in future versions of Xaraya.</para>
    </section>

    <section>
      <title>Using Object Oriented Code</title>

      <para>Modules written as classes is allowed, however the API as
      described in the rest of this document must still be adhered to. The
      simplest way of doing this is to use compatibility functions, for
      example: <programlisting>function mymod_user_main() {
    // Instantiate
    $obj = new myClass();
    // Call relevant method and return output return
    $obj-&gt;usermain();
}</programlisting></para>
    </section>

    <section>
      <title>Checklist</title>

      <para>The following checklist presents a number of items that need
      checking throughout the process of designing, building, and releasing
      your module.</para>

      <para>Initial Decide on the module type Choose a name for your module
      Register your module name Obtain and read the Module Developers Guide
      Obtain and read the API Documentation Module Design Separate User and
      Administration Functions Separate GUI and API functions Design data
      tables Note, which utility modules are of use Note, which standard
      module functions apply Create module security schema Module Build Copy
      the example module directory Create database tables Create database
      initialization routines Test database initialization routines Write
      administration functions Test administration functions Write user
      functions Test user functions Write blocks Test blocks Document module
      API Package your module Module Checks No global variables used No Xaraya
      reserved variable names used No echo() or print() statements used All
      operations protected by xarSecAuthAction() All form results protected by
      xarSecConfirmAuthKey() All form variables obtained by xarVarFetch() All
      output is passed through transform hooks. All output parsed through
      xarVarPrepForDisplay() or xarVarPrepForHTMLDisplay() All variables in
      SQL queries protected by using bindvars All variables in filesystem
      access protected by xarVarPrepForOS() Calls to xarModCallHooks() in
      appropriate locations</para>
    </section>
  </chapter>

  <chapter>
    <title>All others</title>

    <para>Dumping all other remarks for the moment</para>

    <section>
      <title>Recommendations</title>

      <para>If you are new to Xaraya, it is highly recommended that you
      familiarize yourself with Xaraya by reading the Xaraya Installation and
      Getting Started Guide. The guide is currently available via the monotone
      repository located on the mt.xaraya.com website. As a side note, the
      guide is currently a work in progress, once completed the guide will be
      available by means that are more accessible.</para>

      <para>Xaraya News Groups: The following lists of news groups are
      available via news.xaraya.com. These news groups are also available via
      your web browser at the following Web site: http://www.xaraya.com</para>

      <para>Ddf.public – DDF Public List</para>

      <para>Xaraya.announce – Xaraya Announcements List</para>

      <para>Xaraya.devel – Xaraya Member List</para>

      <para>Xaraya.mt-notices - Pushes to the monotone repository, see
      mt.xaraya.com</para>

      <para>Xaraya.documentation – Xaraya Documentation List</para>

      <para>Xaraya.bugs – Xaraya Bugs List</para>

      <para>Xaraya.ui – Xaraya User Interface List</para>

      <para>Xaraya.knowledge-base – Xaraya Knowledge Base List</para>

      <para>Xaraya.marketing – Xaraya Marketing</para>

      <para>Xaraya.patches – Xaraya Patches</para>

      <para>Xaraya.qa – Xaraya Quality Assurance</para>

      <para>Xaraya.user – Xaraya User Discussion List</para>

      <para>Xaraya.user-arabic – Xaraya Arabic User Discussion List</para>

      <para>Xaraya.user.chinese – Xaraya Chinese User List</para>

      <para>Xaraya.user.danish – Xaraya Danish User Discussion List</para>

      <para>Xaraya.user.dutch – Xaraya Dutch User Discussion List</para>

      <para>Xaraya.user.french – Xaraya French User Discussion List</para>

      <para>Xaraya.user.german – Xaraya German User Discussion List</para>

      <para>Xaraya.user.greek – Xaraya Greek User Discussion List</para>

      <para>Xaraya.users.hungarian – Xaraya Hungarian User Discussion
      List</para>

      <para>Xaraya.user.italian – Xaraya Italian User Discussion List</para>

      <para>Xaraya.user.polish – Xaraya Polish User Discussion List</para>

      <para>Xaraya.user.portuguese – Xaraya Portuguese User Discussion
      List</para>

      <para>Xaraya.user.russian – Xaraya Russian User Discussion List</para>

      <para>Xaraya.user.spanish – Xaraya Spanish User Discussion List</para>
    </section>
  </chapter>

  <!-- Index -->
  <index/>

  <!-- Bibliography -->
  &bibliography;
  
  <!-- Glossary -->
  &glossary;
</book>