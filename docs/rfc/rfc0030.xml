<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xsl"?>
    <!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<!-- <?rfc private='my private memo'?>  Produce a private memo rather than a Xaraya-standard --> 
<?rfc toc='yes'?>

<rfc number="0030" category="bcp">
  <!-- number: Fill in the number for the RFC -->
  <!-- obsoletes: Comma separated list of RFC numbers which this one obsoletes -->
  <!-- category: std=standard, bcp=best common practice, info=info, exp=experimental, historic=historic -->

  <!-- Front matter is used for identification of author and organization -->
  <front>
    <title>Permission System</title>
    <author initials="M." surname="Lutolf" fullname="Marc Lutolf">
      <organization>Xaraya Development Group</organization>
      <address>
	<email>marcinmilan@xaraya.com</email>
	<uri>http://www.xaraya.com</uri>
      </address>
    </author>
    <date month="November" year="2002"/>
    
    <!-- Initiating team for this RFC -->
    <workgroup>Project Management Committee</workgroup>

    <!-- List keywords for the RFC here -->
    <keyword>rfc</keyword>
    <keyword>template</keyword>

    <!-- The abstract summarizes in one or two paragraphs the content of the RFC -->
    <abstract>
      <t>This RFC presents a proposal for the Xaraya permissions system. The main difference with respect to the PN permissions system is that permissions are defined as objects independent of users and groups. As a corollary, the structure of users and groups is also revisited.</t>
    </abstract>
  </front>

  <!-- The middle section is used for the actual content of the RFC -->
  <middle>
    <!-- Introduction is mandatory -->
    <section title="Introduction">
	  </t><t>Users and groups are  merged in the implementation into a single class of objects called participants.
	  <t>The issue of translating the current system of using regex for permissions into the permissions of the proposed scheme.
	<t>
	Note on usage: the code is currently implemented as two Xaraya modules: Participants and Security (the latter name to avoid conflict with the Permissions module). The modules can be loaded in the normal way. The interact only with each other and therefore can be tested freely. Each module can also be disinstalled independently. The underlying database tables should only be manipulated through the module interface. 
	</t>
<t>
				<list style="symbols">
					<t>The main points of this RFC are:</t>
					<t>	  
						<list style="symbols">
							<t>Permissions are defined as objects that can be manipulated independently of users and groups.</t>
							<t>Users and groups are conceptually (and in the implementation) merged to a single class of objects called participants.</t>
							<t>Both participants and permissions can have unlimited levels of subgoups of participants and permissions respectively.</t>
							<t>Permission objects, i.e. objects that have permissions associated with them, are registered when a module is initiated.</t>
						</list>
					</t>
					<t>Benefits:</t>
					<t>
						<list style="symbols">
							<t>Permissions can be manipulated independently of participants. We can create groups of permissions, adding or deleting the components.
							</t>
							<t>We can then assign permissions groups to participants in a single statement.
							</t>
							<t>Registering permissions objects allows us to make visible to the user the available permissions to be set.
							</t>
						</list>
					</t>
					<t>This RFC does not cover:</t>
					<t>
						<list style="symbols">
							<t>The UI of the permissions system
							</t><t>The issue of translating the current system of using regex for permissions into the permissions of the proposed scheme.
							</t><t>Whether and how regex should be allowed in the new UI.
							</t>
						</list>
					</t>
					<t>Note: This RFC has borrowed generously from the concepts underlying the Java packages java,security and java.security.acl. These can be found at: 
						<eref target="http://java.sun.com/j2se/1.3/docs/api">http://java.sun.com/j2se/1.3/docs/api</eref>
					</t>
				</list>
			</t>
    </section>

    <!-- One content section is mandatory -->
    <section title="Concept">
    <section title="Permissions">
	<t>
    Permissions are defined as objects without reference to any group. A permission is an object that incorporates:
	</t>
	<list style="symbols">
	  <t>A reference to the Realm it applies to. In addition to the list of available realms, a permission can also apply to "None" or "All".
	  </t>	
	  <t>A reference to the Module it applies to. In addition to the list of available modules, a permission can also apply to "None" or "All".
	  </t>	
	  <t>A reference to the Component within the Module it applies to. In addition to the list of available components of a module, a permission can also apply to "None" or "All".
	  </t>	
	  <t>A reference to the Instance of the Component it applies to. In addition to the list of available instances, a permission can also apply to "None" or "All".
	  </t>	
	  <t>A permissions Level it refers to. The levels have the usual.values of ACCESS_NONE to ACCESS_ADMIN (numeric 0 - 800).
	  </t>	
  	</list>
	<t>
	Permissions can contain other permissions. All the permissions in the system are grouped in a tree. In addition to the attributes described above a permission can have any number of "child" permissions. A permission can also have any number of "parent" permissions.
	</t>
	<t>
	A permission accumulates the attributes of its parent(s). During a security check all the parent permissions will be taken into account. Since each permission refers to a single realm/module/component/instance combination, you create more complex permissions schemes by  successively adding permissions to the tree.
	</t>

	<t>
	For a given realm/module/component/instance combination the child permission will override any parent. For permissions not overriden, the highest permission "wins".
	</t>
	
	Note Version 1.0: The code doesn't yet support multiple parents.
	<t>
	For convenience two permissions are created at initialization time. They cannot be modified or deleted. These are:
	</t>

<artwork>

    NoPermissions
    |
    |--FullPermissions
    
    
</artwork>

	<t>
	NoPermissions is the permission at the root of the permissions tree, representing the lowest level of access to all Xaraya modules, i.e. no access. It has the attributes:
<artwork>

    Realm     Module    Component    Instance    Level
    --------- --------- ------------ ----------- -----------
    All       All       All          All         ACCESS_NONE
    
    </artwork>
	
	</t>
	<t>
	FullPermissions is the permission representing the highest level of access to all Xaraya modules, i.e. the ability to do anything. It has the attributes:
<artwork>

    Realm     Module    Component    Instance    Level
    --------- --------- ------------ ----------- ------------
    All       All       All          All         ACCESS_ADMIN
    
    </artwork>
	
	</t>

    </section>
        <section title="Users/Groups">
	<t>
    Users and Groups of users are implemented as a single object type: Participants. Like permissions, participants are arranged in a tree. A given participant that is defined as a group can have any number of subgroups or users under it. Users can have no children.
	</t>
	<t>
    In the UI the more familiar terms Users and Groups are used in order to avoid confusion. In addition, since one can expect numerically many more Users than Groups, the former are not displayed by default. Rather, one can specifically request to see the Users belonging to a given Group.
	</t>
	<t>
	Note Version 1.0: The code doesn't yet support multiple parents.
	</t>
	<t>
	For convenience a number of participants are created at initialization time. They are:
	</t>

<artwork>

    Everybody (G)
    |
    |--Oversight (G)
    |  |
    |  |--Overseer (U)
    |  
    |--Admins (G)
    |
    |--Users (G)
    |
    |--Anonymous (U)
    |
    |--Current (U)
        
</artwork>
	<t>
    Everybody: This is the root of the participants tree and is defined as a group that contains all other subgroups and users. This participant cannot be deleted or modified.
	</t>
	<t>
    Oversight: This is a group that contains those users that can do anything in the system, a sort of superuser. The Oversight group contains one such user, the Overseer. Both the Oversight group and the Overseer cannot be modified or deleted.
	</t>
	<t>
    Admins: This is a group that contains users that are administrators of the site. This participant may be modified or deleted.
	</t>
	<t>
    Users: This is a group that represents users of the site. This participant may be modified or deleted.
	</t>
	<t>
    Anonymous: This is a user that represents users of the site that are not logged in. This participant may be modified or deleted.
	</t>
	<t>
    Current: This is a user that represents the current user of the system. At runtime Current is the user querying the permissions system. This participant cannot be modified or deleted.
	</t>

    </section>
    <section title="Default Assignments">
	<t>
	In order for the permissions system to do something useful, permissions need to apply to users and groups. This is done by assigning permission objects to participants in the UI. Theoretically any permission can be assigned to any participant. Configuration of permissions is the responsibility of the site administrator.
	</t>
	<t>
	For convenience a number of assignments are made at initialization time. These cannot be changed.
	</t>
	<t>	
	The participant Everybody is assigned the permission NoPermissions. In other words, Everybody can do nothing.
	</t>
	<t>	
	Open Issue: should Everybody be assigned a higher permissions level, such as ACCESS_OVERVIEW?
	</t>
	<t>	
	The participant Oversight is assigned the permission FullPermissions. In other words, members of the Oversight group can do anything.
	</t>
	<t>	
	Version 1.0: The code doesn't yet deal with inheritance. For illustration's sake the user Overseer is also assigned FullPermissions.
	</t>
    </section>
    </section>
    <section title="Architecture">
	<t>
	The permissions system is implemented through the following objects:</t>
	  <t>An implementation of the  Participants object conceptually replaces the tables xar_user and xar_groups. The code for manipulating participants will deal with the issue of whether the participant is a group or a user and handle things accordingly.
     <t>The following presents the concepts underlying the proposal,
     as well as suggestions concerning the structure of database
     tables. A listing of pseudo-code covering the objects discussed
     can be found in the appendices.
     </t>
			<t>The permissions proposal revolves around the following objects:</t>
			<section title="Participants">
				<t>
					A central repository of user and group definitions. Each user,
					group, group of groups etc. is a participant with an entry in
					this repository.
				</t>
				<t>An implementation of the Participants object conceptually
				replaces the tables pn_user and pn_group. The code for
				manipulating participants will deal with the issue of whether
				the participant is a group or a user and handle things
				accordingly.
				</t>
				<t>
					<artwork>
Methods:    getgroups          returns an array representing all the participants
                               of type group in the system.
                               Note: should be private.
            getgroup           returns a single participant of type group based on its ID.
                               Note: should be private.
            getsubgroups       returns all the subgroups of a given participant based 
                               on its ID.
            getParticipant     returns a participant (group or user) based on its ID.
            makeTree           returns a tree representation of the participants of 
                               type group.
            drawtree           returns a crude HTML drawing of a tree generated by maketree.
                               Note: needs to be moved out to the templates.
</artwork>
     </t>
    </section>
	<section title="SecuritySchemas">
      <t>A central repository of permissions schemas (policies). The schemas are normally defined and registered as entries with Schemas upon installation of a module. There needs to be a restricion that assigned names for components need to be unique within a module.

<artwork>
Methods:    listall            gets a list of all the schema entries
            getEntry           get a schema based on its id or its name
</artwork>
     </t>
    </section>
	<section title="Permissions">
      <t>A central repository for permissions defined at any given time. No duplicate permissions are allowed.

<artwork>
Methods:    getpermissions     returns an array representing all the permissions
                               in the system.
                               Note: should be private.
            getpermissionfast  returns an array representing a single permission
                               based on its ID.
                               Note: should be private.
            getsubpermissions  returns all the child permissions of a given permission
                               based on its ID.
            getmodules         returns an array of all the registered modules.
                               Note: Move out?
            getrealms          returns an array of all the registered realms.
                               Note: Move out?
            getParticipant     returns a permission based on its ID.
            makeTree           returns a tree representation of the permissions.
            drawtree           returns a crude HTML drawing of a tree generated by maketree.
                               Note: needs to be moved out to the templates.
</artwork>
     </t>
    </section>
	<section title="Participant">
      <t>An object representing a single group or user.

<artwork>
Methods:            
     constructor
     add               add this participant to the Participants repository.
     remove            remove this participant from the Participants repository.
     update            update this participant in the Participants repository.
     addMember         add a child participant to this participant.
     removeMember      remove a child participant from this participant.
     getUsers          get an array representing the child participants 
                       of type User of this participant.
     getAllPermissions get an array representing all the permissions defined.
     getPermissions    get an array representing the permissions assinged to
                       this participant.
     getChildren       gets a list of the participants who are members of this participant
     getParents        gets a list of the participants who this participant is a member of
     getAncestors      recursive getParents
     getDescendants    recursive getChildren
     isMember          check whether a participant is a member of this participant
     isUser            check whether this participant is a user
     equals            check whether a participant is the same as this participant
     gets              all the interesting variables
     sets              all the interesting variables except the ID
     assignPermission  assign a permission to this participant
     removePermission  remove a permission from this participant  
     
     //Methods that are useful but have no bearing on the permissions problem.
     getInfo           get an information field of the participant (user)
     setInfo           set an information field of the participant (user)

</artwork>
     </t>
    </section>
	<section title="SecuritySchema">
      <t>An object representing a single permission schema.
<artwork>
Methods:            
     constructor            
     add            add this schema to the Schemas repository
     remove         remove this schema from the Schemas repository
     equals         check whether a participant is the same as this participant
     implies        check whether an entry implies this entry
     gets           all the interesting variables
     sets           all the interesting variables except the ID
     challenge      check the permisssions of a participant
</artwork>
     </t>
    </section>
	<section title="Permission">
      <t>An object representing a single permission. This extends SecuritySchema
<artwork>
Methods:            
     constructor
     add             add this permission to the Permissions repository.
     remove          remove this permission from the Permissions repository.
     update          update this permission in the Permissions repository.
     addMember       add a child permission to this permission
     removeMember    remove a child permission from this permission
     getChildren     gets a list of the participants who are members of this participant
     getParents      gets a list of the participants who this participant is a member of
     getAncestors    recursive getParents
     getDescendants  recursive getChildren
</artwork>
     </t>
    </section>
    </section>
	<section title="Database Tables">
	<section title="Group and Users Tables">
      <t>The tables xar_groups and xar_users can be merged into a new Participants table. The table xar_group_membership also changes:

<artwork>
Table xar_participants     Table xar_partmembers
xar_pid                    xar_pid
xar_name                   xar_parentid
xar_type
xar_parent
xar_uname
xar_email
xar_pass
xar_url
xar_auth_module
</artwork>
The field xar_type is 0 implies child is a user, 1 implies child is a group. Calls to groups and users in the API have to be appropriately modified to look up the new table.
     </t>
    </section>
	<section title="SecuritySchema Table">
      <t>
<artwork>
Table xar_securityschemas
xar_pid
xar_name
xar_realm
xar_module
xar_component
xar_instance
xar_level
xar_description
</artwork>
</t>
    </section>
	<section title="Permissions Table">
      <t>
<artwork>
Table xar_permissions      Table xar_permmembers
xar_pid                    xar_pid
xar_name                   xar_parentid
xar_realm
xar_module
xar_component
xar_instance
xar_level
xar_description
</artwork>
</t>
    </section>
	<section title="ACL Table">
      <t>
<artwork>
Table xar_acl
xar_partid
xar_permid
</artwork>
</t>
    </section>
    </section>

 	<section title="Syntax">
      <t>The module developer needs to register each permissons obect in his module as a SecuritySchema object. This is done by placing something like the following line in the xarinit.php file:

<artwork>
new xarSecuritySchema(  "addadownload",      // what I'm going to call this schema
                        0,                   // the realm
                        "AddDownload",       // the component
                        "*",                 // the instance
                        ACCESS_ADMIN,        // the threshold permission level
                        "admins only")       // an explanatory comment
</artwork>
Such a call can also be inserted when a new instance is created. This would let have the user define permissions at run time. (can of worms, here)

Checking a permission is done with:

xarSecuritySchemas.getEntry("addadownload").challenge();

Note in this call both the module and the participant are implied, because we can get both from session vars (?). A more complete call would be:

xarSecuritySchemas.getEntry("Downloads","addadownload").challenge($thisparticipant);


To ensure backward compatibility we define something like:
<artwork>
function xarSecAuthAction($realm,$component,$instance,$level,$userid=NULL){
            //..preparatory stuff to find the right schema
            // if it doesn't exist we'll have to create it
            // IMPORTANT: need explode any regex...
            if (xarSecuritySchemas.getEntry($schema).challenge()) {
            return true;
            }
            return false;
}
</artwork>
Note there needs to be a translation layer which transforms any regular expressions in the call into schemas compatible with what's in the xar_securityschemas table. Since this problem was implicitly solved in the current version of the permissions system I'm assuming we'll just borrow from that code.
</t>
    </section>
    <section title="Open Issues">
    <section title="Regex">
      <t>I'd rather dispense with this and run the UI through dropdowns and checkboxes, but I understand that some people are clamoring for an "advanced user" UI for the permissions system. There may also be some performance considerations here, trading CPU processing for DB hits. And then there's backwards compatibility. Well, OK.
</t><t>My suggestion for the future would be to limit the advanced UI to entering lists into the appropriate form fields, say a "Component" or "Instance" field in the UI. On submitting, the list(s) would be disassembled to records in the permissions table with one component/instance per record. This in itself is not trivial, because the user would be entering some sort of name, and you'd have to parse the name, make sure it corrsponded to a real object registered in the permissions system, and then translate it to a numeric ID.

</t>
    </section>
    <section title="Multi-language">
      <t>Need to check to make sure any calls using the name of an object rather than its ID don't screw up the ML capabilities.
</t>
    </section>
    <section title="Future Implementation">
      <t>The issues encountered in Version 1.0 suggest merging the Participants and Security modules into a single module in the future.
</t>
    </section>
    <section title="Miscellaneous Notes To Do">
<t>	<list style="symbols">
	<t>Need to check that all the recursive functions don't crash if nothing is found.
</t><t>Need to optimize the functions so as to cut down the number of DB calls where possible.
</t><t>Need to integrate a regex translation layer for backward compatibility.
</t>
</list>
</t></list></t>
    </section>
    </section>
   <!-- Revision history is mandatory -->
    <section title="Revision history">
      <t>Version 0.9, Dec 15, 2002: First release of this document</t>
      <t>Version 1.0, Jan 15, 2003: Major rewrite based on the first version of the code. Clearer definition of the architecture, implementation and UI.</t>
    </section>

  </middle>

  <!-- Back matter is used for references and appendices which come after the references -->
  <back>
    <references title="Reference title">
      <!-- Fill in references as needed -->
      <reference>
	<front>
	  <title>Reference title</title>
	  <author>
	    <organization>Organization</organization>
	  </author>
	  <date year="2002"/>
	</front>
      </reference>
      <!-- Repeat the aboven block if more references are needed -->
    </references>
    
    <!-- Any section after this will become an appendix -->

  </back>
</rfc>
