<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xsl"?>
    <!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<!-- <?rfc private='my private memo'?>  Produce a private memo rather than a Xaraya-standard --> 
<?rfc toc='yes'?>

<rfc number="0007" category="info">
  <front>
    <title>Modularized Data</title>
    <author initials="G." surname="Rothfuss" fullname="Gregor J. Rothfuss">
      <organization>Project Management Core</organization>
      <address>
	<email>gregor@xaraya.com</email>
	<uri>http://www.xaraya.com</uri>
      </address>
    </author>
    <author initials="J." surname="Schrage" fullname="Jan Schrage">
      <organization>Xaraya Development Team</organization>
      <address>
	<email>jan@xaraya.com</email>
	<uri>http://www.xaraya.com</uri>
      </address>
    </author>
    <date month="January" year="2002"/>
    
    <!-- The abstract summarizes in one or two paragraphs the content of the RFC -->
    <abstract>
      <t>This RFC proposes to have a unified mechanism to extend modules with custom data.</t>
    </abstract>
  </front>
  
  <!-- The middle section is used for the actual content of the RFC -->
  <middle>
    <!-- One content section is mandatory -->
    <section title="Introduction">
      <t></t>
    </section>
    <section title="General statements about Modularized Data">
      <t></t>
    </section>
    <section title="List of requirements for Modularized Data">
      <t></t>
    </section>
    <section title=" Solution proposals - database tables">
      <t>
        This is the DB setup as extracted from the admin API.
		<figure><artwork src="images/rfc0007_2.png"/></figure>
     </t>
     <t>   
     This design is for text-based dynamic data.
		<figure><artwork src="images/rfc0007_1.png"/></figure>
		This design is for user data that can be assigned to groups,
        with optional selection lists for fields, i.e. for dropdowns.
		<figure><artwork src="images/rfc0007_3.png"/></figure>
	  </t>
          <t>
	This design attempts to merge Dynamic Data, Dynamic User Data and Module
        Variables. Values are serialized to support transparent storage of complex
        types (arrays etc). Each type has a default BL tag for rendering, which can
        be overwritten in the property. Properties are referenced by module name.
			</t>
		<figure><artwork src="images/rfc0007_5.png"/></figure>
    </section>
    <section title="Table 'Content'">
      <t></t>
    </section>
    <section title=" Solution proposals - APIs">
      <t>
      Dynamic Data will use two sets of APIs. Creation and Deletion of of variables is done within
      a module, while reading and writing variable contents is done in the core.

      There are currently discussions whether to combine Dynamic User Data with generalized
      Dynamic Data, in essence abstracting away the relationship between users and dynamic
      data, and allowing every module to define its own dynamic data. This brings up the question
      if module variables are being reinvented, and what should happen with the functionality
      to assign responsibility for storing user variables to authentication modules. 

      The current core API functions are:
		<figure><artwork src="images/rfc0007_4.png"/></figure>
      </t>
      <section title="Review of the current DD API with extension proposals">
	
	<t>
function dynamicdata_adminapi_createprop($args)
/**
 * create a new property field
 *
 * @author the DynamicData module development team
 * @param $args['modid'] module id of the item field to create
 * @param $args['itemtype'] item type of the item field to create
 * @param $args['label'] name of the field to create
 * @param $args['type'] type of the field to create
 * @param $args['default'] default of the field to create
 * @param $args['validation'] validation of the field to create
 * @returns int
 * @return dynamicdata prop ID on success, false on failure
 * @raise BAD_PARAM, NO_PERMISSION, DATABASE_ERROR
 */

Proposed extentions:

* @param $args['active'] boolean: is this property active, i.e. usable?
* @param $args['order']  int: sort order for display
* @param $args['tag'] string: BL tag that handles the output
       </t>
	<t>
function dynamicdata_adminapi_updateprop($args)
/**
 * update a property field
 *
 * @author the DynamicData module development team
 * @param $args['prop_id'] property id of the item field to update
 * @param $args['modid'] module id of the item field to update (optional)
 * @param $args['itemtype'] item type of the item field to update (optional)
 * @param $args['label'] name of the field to update
 * @param $args['type'] type of the field to update
 * @param $args['default'] default of the field to update (optional)
 * @param $args['validation'] validation of the field to update (optional)
 * @returns bool
 * @return true on success, false on failure
 * @raise BAD_PARAM, NO_PERMISSION, DATABASE_ERROR
 */

Proposed changes:

Add:
* @param $args['active'] boolean: is this property active, i.e. usable?
* @param $args['order']  int: sort order for display
* @param $args['tag'] string: BL tag that handles the output

Delete: 
* modid: A property that belongs to a specific module should remain there
* itemtype: Update of item types may break the module logic. Should be handled 
            by deletion and new creation
* type: Likewise.
       </t>
	<t>
function dynamicdata_adminapi_deleteprop($args)
/**
 * delete a property field
 *
 * @author the DynamicData module development team
 * @param $args['prop_id'] property id of the item field to delete
// TODO: do we want those for security check ? Yes, but the original values...
 * @param $args['modid'] module id of the item field to delete
 * @param $args['itemtype'] item type of the item field to delete
 * @param $args['label'] name of the field to delete
 * @param $args['type'] type of the field to delete
 * @param $args['default'] default of the field to delete
 * @param $args['validation'] validation of the field to delete
 * @returns bool
 * @return true on success, false on failure
 * @raise BAD_PARAM, NO_PERMISSION, DATABASE_ERROR
 */

Proposed changes:

Delete all parameters except prop_id and modid.
For security check ensure a module can delete only its own properties.
It should, however, be allowed to delete any of them.
        </t>
<t>
Proposed new functions:
</t>
<t>
function getAllProperties(modid)
/**
* get a list of all properties for module $modid
* and their basic type and BL tags
* @returns array(propid,type,tag)
*/
</t>
      </section>
    </section>
    <section title="Proposal for a data dictionary">
      <t>
       DB tables: TODO
       <figure><artwork src=""/></figure>
      </t>

      <t>
       API: TODO
       <figure><artwork src="images/rfc0007_6.png"/></figure>
      </t>
</section>

    <section title="Relationship to other areas">
      <t>It will need to be determined if it makes sense to allow storage of certain properties
      via the modular authentication system. For instance, it could be beneficial to store
      dynamic properties for the users module in LDAP. Also, it needs to be determined how and
      if dynamic properties integrate with the Multilangue system. Marco has some thoughts about
      this, i hope he will share them soon. Property validation should be done by using the
      facilties provided by xarVarValidate.</t>
    </section>
    <section title="Code that will need to be rewritten">
      <t>xarUserGetVar, xarUserSetVar and xarUserValidateVar will go away, to be replaced
      by xarModGetVar, xarModSetVar, xarVarValidate respectively.</t>
    </section>
    <section title="Tools that need to be created from scratch">
      <t></t>
    </section>
    <section title="Basic documents for this RFC 7">
      <t></t>
    </section>
    <section title="Retractions">
      <t></t>
    </section>
    <section title="Author contact">
      <t></t>
    </section>
    <section title="Changelog">
      <t></t>
    </section>
  </middle>
</rfc>
