<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xsl"?>
    <!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<!-- <?rfc private='my private memo'?>  Produce a private memo rather than a Xaraya-standard --> 
<?rfc toc='yes'?>

<rfc number="0030" category="bcp">
  <!-- number: Fill in the number for the RFC -->
  <!-- obsoletes: Comma separated list of RFC numbers which this one obsoletes -->
  <!-- category: std=standard, bcp=best common practice, info=info, exp=experimental, historic=historic -->
  
  <!-- Front matter is used for identification of author and organization -->
  <front>
    <title>Security System</title>
    <author initials="M." surname="Lutolf" fullname="Marc Lutolf">
      <organization>Xaraya Development Group</organization>
      <address>
        <email>marcinmilan@xaraya.com</email>
        <uri>http://www.xaraya.com</uri>
      </address>
    </author>
    <date month="November" year="2002"/>
    
    <!-- Initiating team for this RFC -->
    <workgroup>Developer pool</workgroup>
    
    <!-- List keywords for the RFC here -->
    <keyword>rfc</keyword>
    <keyword>privileges</keyword>
    <keyword>security</keyword>

    <!-- The abstract summarizes in one or two paragraphs the content of the RFC -->
    <abstract>
      <t>
        This RFC presents a proposal for the Xaraya security
        system. The main difference with respect to the existing security
        system is that privileges are defined as objects independent
        of users and groups. As a corollary, the structure of users
        and groups is also revisited.
      </t>
    </abstract>
  </front>
  
  <!-- The middle section is used for the actual content of the RFC -->
  <middle>
    <section title="Definition of terms">
      <t>
        To avoid confusion before specifying anything, here is the list of terms
        we use in relation to the security system.
        <list style="symbols">
          <t>
            Component: The name for an object-type that can be protected with
            the security system.
          </t>
          <t>
            Instance: The name for an identifier for a specific instance of a
            component.
          </t>
          <t>
            Access level: A number that defines the level of access in a privilege or a mask.
          </t>
          <t>
            Privilege: An object defined by a component, instance and an access level that together define the access to the component.
          </t>
          <t>
            Mask: A tuple for a component specifying how it can be protected.
            The tuple consists of a component name, an instance name and an access level. The mask specifies how a privilege need be defined for access to the component.
            Masks are registered upon module initialisation.
          </t>
          <t>
            Role: A named set of 1 or more users. A role can correspond to a group or a user.
          </t>
        </list>
      </t>
    </section>
    <!-- Introduction is mandatory -->
    <section title="Introduction">
      <t>
        <list style="symbols">
          <t>
            The main points of this RFC are:
            <list style="symbols">
              <t> 
                Privileges are defined as objects that can be
                manipulated independently of their specific assignments 
                to roles.
              </t>
              <t>
                Users and groups are merged in the implementation
                into a single class of objects called roles.
              </t>
              <t>
                Both roles and privileges can have unlimited
                levels of subroles and subprivileges respectively.  
              </t>
              <t>
                Components, i.e. objects
                that can have privileges assigned to them through their registered
                mask.
              </t>
            </list>
          </t>
          <t>Benefits:
            <list style="symbols">
              <t>
                Privileges can be manipulated independently of
                roles. We can create groups of privileges, adding or
                deleting their components.  
              </t>
              <t>
                We can then assign (compound) privileges to roles in a
                single statement.
              </t>
              <t>
                Registering components allows us to
                make visible to the user the available privileges to
                be set.
              </t>
            </list>
          </t>
          <t>This RFC does not cover:
            <list style="symbols">
              <t>
                The issue of translating the current system of using
                regex for privileges into the privileges of the
                proposed scheme.  
              </t>
              <t>
                Whether and how regex should be allowed in the new UI.
              </t>
            </list>
          </t>
          <t>
            Note: This RFC has borrowed generously from the concepts
            underlying the Java packages java,security and
            java.security.acl. These can be found at: <eref
            target="http://java.sun.com/j2se/1.3/docs/api">http://java.sun.com/j2se/1.3/docs/api</eref>
          </t>
        </list>
      </t>
      <t>
        Note on usage: the code is currently implemented as two Xaraya
        modules: Roles and Privileges. The modules can be
        loaded in the normal way. They interact only with each other
        and therefore can be tested freely. Each module can also be
        disinstalled independently. The underlying database tables
        should only be manipulated through the module interface.
      </t>
    </section>
    
    <!-- One content section is mandatory -->
    <section title="Concepts of the Xaraya Security System">
      <section title="Roles">
        <t>
          Roles is a generalization of the Users and Groups
          concepts in PostNuke. In Xaraya both Users and Groups of
          users are implemented as roles. As in PostNuke,
          roles that are Users can be members of other
          roles that are Groups. The difference to the PostNuke
          concepts is that there is no limit to the levels of nesting
          available. In addition, a role can be a member of any
          number of other roles.
        </t>
        <t>
          The roles in Xaraya are arranged in a hierarchy or
          tree, and every role defined must be a member of at
          least one already existing role. At the top of the
          hierarchy is a role called "Everybody".
        </t>
        <t>
          Note: Contrary to the PostNuke permissions system, the order
          in which multiple parents of a role are defined is
          not relevant for the way privileges are applied and has no
          impact on whether access is granted or denied.
        </t>
        <t>
          The following rules apply to the roles hierarchy:
          <list style="numbers">
            <t>
              Roles defined as Users cannot themselves have children.
              (i.e. a role which has one user is a leaf of the roles tree)
            </t>
            <t>
              A role cannot be a parent of one of its
              ancestors in the hierarchy; obviously to prevent endless loops. 
              A role also cannot be its own child.
            </t>
            <t>
              A role cannot have another role as a child
              more than once. (This is not strictly necessary, but it
              avoids confusion.) Note, however, that it is possible
              for a role to be a child and simultaneously a
              grandchild of another role, as the following
              example shows.
            </t>
          </list>
          <artwork>
            Role A             Big Boss
            |                  |
            |--Role B          |--Small Boss
            |  |               |  |  
            |  |--Role C       |  |--John Doe
            |                  |
            |--Role C          |--John Doe
          </artwork>
          John both reports to "Big Boss" and "Small Boss" and has as such two roles
          in the system.
        </t>
        <t>
          In the user interface we use the term "User" for roles which
          have one member and "Group" for roles which have multiple
          members. Conceptually however there is no difference between
          the two, both are roles.  Since one can expect numerically
          many more Users than Groups or, in other terms, more leaves
          then nodes, the former are not displayed by default. Rather,
          one can specifically request to see the Users belonging to a
          given Group.
        </t>
        <t>
          For convenience a number of roles are created at
          initialization time. They are:
          <artwork>
          
            Everybody (Group)
            |
            |--Oversight (Group)
            |  |
            |  |--Overseer (User)
            |  
            |--Admins (Group)
            |
            |--Users (Group)
            |
            |--Anonymous (User)
            |
            |--Current (User)
          </artwork>
        </t>
        <t>
          Everybody: This is the root of the roles tree and is defined
          as a group that contains all other subgroups and users. This
          role cannot be deleted or modified.
        </t>
        <t>
          Oversight: This is a group that contains those users that
          can do anything in the system, a sort of superuser. The
          Oversight group contains one such user, the Overseer. Both
          the Oversight group and the Overseer cannot be modified or
          deleted.
        </t>
        <t>
          Admins: This is a group that contains users that are
          administrators of the site. This role may be modified or
          deleted.
        </t>
        <t>
          Users: This is a group that represents users of the
          site. This role may be modified or deleted.
        </t>
        <t>
          Anonymous: This is a user that represents users of the site
          that are not logged in. This role may be modified or
          deleted.
        </t>
        <t>
          Current: This is a user that represents the current user of
          the system. At runtime Current is the user querying the
          privileges system. This role cannot be modified or deleted.
        </t>
      </section>

      <section title="Privileges">
        <t>
          The Xaraya concept of privileges has a structure similar to
          privileges in PostNuke. A privilege is an object that
          incorporates:
          <list style="symbols">
<!--
            <t>
              A reference to the Realm it applies to. In addition to
              the list of available realms, a privilegep can also apply to
              "None" or "All".  
            </t> 
-->
            <t>
              A reference to the Module it [MrB: this is strictly not necessary,
              for the UI however it is convenient. For the privilege it is not
              relevant which module has registered the component etc.]
              applies to. In addition to the list of available modules, a
              privilege can also apply to "None" or "All".  
            </t> 
            <t>
              A reference to the Component within the Module it applies
              to. In addition to the list of available components of a
              module, a privilege can also apply to "None" or "All".
            </t> 
            <t>
              A reference to the Instance of the Component it
              applies to. In addition to the list of available instances,
              a privilege can also apply to "None" or "All".  
            </t> 
            <t>
              A privileges Level it refers to. The levels have the
              usual.values of ACCESS_NONE to ACCESS_ADMIN (numeric 0 -
              800).
            </t>
          </list>
        </t>
        <t>
          In addition, each privilege also has:
          <list style="symbols">
            <t>
              A name which identifies it. The name is used as a
              shorthand reference to the privilege in the UI and must
              be unique. It is good practice to use names that help
              understand what a privilege gives away on protection, such 
              as "ReadAll" or  "DeleteExamplesAll".  
            </t> 
            <t>
              A description that contains detail information about the
              privilege. The description is meant as documentation to
              developers and is not referenced in the UI. It is not
              mandatory.
            </t>
          </list>
        </t>
        <t>
          Similar to roles, privileges can be composed of other
          privileges. In addition to the attributes described above a
          privilege can have any number of subprivileges. A privilege
          can also be a component of any number of "parent"
          privileges. However, privileges do not live in a single
          hierarchy. Instead, the UI presents all the privileges in a
          list, with each privilege containing its children in a
          separate tree, as the following example shows:
          <artwork>
            NoPrivileges                a privilege with no children
            
            FullPrivileges              another privilege with no children
            
            ReadAll                     a privilege with 2 children and a grandchild
            |
            |--DeleteExamplesAll
            |  |
            |  |--CommentArticles
            |  
            |--AddContact
          </artwork>
        </t>
        <t>
          In the above example note that although the names are
          suggestive of certain behaviour there is no fixed naming
          rule. You can assign any names you want as long as they are
          unique. Furthermore there is no rule for how to group
          privileges, for instance by module. A good administrator
          will structure his privileges according to the roles he
          wants to assign them to, rather than by component or level.
        </t>
        <t>
          In Xaraya privileges are defined without reference to any
          group or user. They are objects with no relevance until they
          are assigned to one or more roles. As explained below,
          assigning the head of a privileges tree to a role assigns
          ALL the components of the tree of that privilege.
        </t>
        <t>
          For convenience a number of privileges have been created
          at initialization time. These are:
          <list style="symbols">
            <t>
              "NoPrivileges" is the privilege representing the lowest
              level of access to all Xaraya modules, i.e. no access. This Privilege cannot be modified or
          deleted. It
              has the attributes:
              <artwork>
                Realm     Module    Component    Instance    Level
                --------- --------- ------------ ----------- -----------
                All       All       All          All         ACCESS_NONE   
              </artwork>
            </t>
            <t>
              FullPrivileges is the privilege representing the highest
              level of access to all Xaraya modules, i.e. the ability to
              do anything. This privilege cannot be modified or
          deleted. It has the attributes:
              <artwork>
                Realm     Module    Component    Instance    Level
                --------- --------- ------------ ----------- ------------
                All       All       All          All         ACCESS_ADMIN    
              </artwork>
            </t>
          </list>
        </t>
        <t>
          The following privileges are also created but can be
          modified or deleted
          <artwork>
            Name     Realm     Module    Component    Instance    Level
            -------- --------- --------- ------------ ----------- ------------
            ReadAll  All       All       All          All         ACCESS_READ    
            EditAll  All       All       All          All         ACCESS_EDIT    
            AddAll   All       All       All          All         ACCESS_ADD    
          </artwork>
        </t>
        <t>
          Note Version 1.0: A privilege can also be empty, i.e. not
          have any attributes. In this case it is just a container for
          other privileges.
        </t>
      </section>

      <section title="Access Levels">
        <t>
          As mentioned above Xaraya uses the access levels
          originally defined in PostNuke. These are:
          <artwork>
            Name              Level
            --------------    -----
            ACCESS_NONE          0
            ACCESS_OVERVIEW    100
            ACCESS_READ        200
            ACCESS_COMMENT     300
            ACCESS_MODERATE    400
            ACCESS_EDIT        500
            ACCESS_ADD         600
            ACCESS_DELETE      700
            ACCESS_ADMIN       800
          </artwork>
        </t>
        <t>
          The levels are cumulative. A given level implies the right
          to all the levels below it. The right to DELETE implies the
          rights to ADD, EDIT, MODERATE etc.
        </t>
        <t>
          There is also no provision for ALLOW and DENY, as in some
          other ACL systems.
        </t>
        
      </section>

      <section title="Irreducible Sets">
        <t>
          As noted above, when two privileges are defined on the same
          module, component and instance the one with the
          higher access level includes the right to the one with the
          lower level. We say that the privilege with the
          higher access level implies the other. In the following
          example two privileges are defined on the Examples module:
          
          <artwork>
            Name     Realm     Module    Component    Instance    Level
            -------- --------- --------- ------------ ----------- ------------
            ReadExp  All       Examples  All          All         ACCESS_READ    
            EditExp  All       Examples  All          All         ACCESS_EDIT    
          </artwork>
          
          The privilege EditExp implies ReadExp.
        </t>
        <t>
          Note that two privileges A and B are considered equal
          (identical) if A implies B and B implies A.
        </t>
        <t>
          In the following example, however:
          <artwork>
            Name     Realm     Module    Component    Instance    Level
            -------- --------- --------- ------------ ----------- ------------
            ReadExp  All       Examples  All          All         ACCESS_READ    
            EditArt  All       Articles  All          All         ACCESS_EDIT    
            EditArt1 1         Articles  All          All         ACCESS_EDIT    
          </artwork>
          none of the privileges imply any of the others, as they
          refer to different modules and/or realms. We call such
          privileges disjoint. (NOTE: This example contains a Realm which is a
          feature which will not be used in the initial implementation.)
        </t>
        <t>
          Definition: An Irreducible Set of privileges is a set in
          which all the privileges are disjoint.
        </t>
      </section>
      
      <section title="Winnowing">
        <t>
          Definition: Winnowing is the process by which the Xaraya
          privileges system creates irreducible sets of privileges.
        </t>
        <t>
          A privilege accumulates the attributes of its
          children. As mentioned above since each privilege refers
          to a single realm/module/component/instance combination, you
          create more complex privilege-schemes by successively
          adding privileges to the tree. During a security check all
          the component privileges in the tree will be taken into
          account.
        </t>
        <t>
          However, in any given tree not all the privileges will
          necessarily be relevant. Take the following example:
          <artwork>    
            ReadAll                      
            |
            |--DelExp
            |  |
            |  |--AddExp
            |  
            |--EditArt
            |  
            |--AddArt
            
            with the following definitions:
            
            Name     Realm     Module    Component    Instance    Level
            -------- --------- --------- ------------ ----------- ------------
            1. ReadAll  All       All       All          All         ACCESS_READ    
            2. DelExp   All       Examples  All          All         ACCESS_DELETE    
            3. AddExp   All       Examples  All          All         ACCESS_ADD    
            4. EditArt  All       Articles  All          All         ACCESS_EDIT    
            5. AddArt   All       Articles  All          All         ACCESS_ADD   
          </artwork>
          It can be seen that, with the definitions given above, 2
          implies 3 and 5 implies 4. Therefore when comparing all the
          privileges in the set, privileges 3 and 4 are not
          relevant, because they are superceded by 2 and 5
          respectively.
        </t>
        <t>
          During the winnowing process the privileges system compares
          each privilege in a tree with all the others in the same
          tree and discards those privileges implied by others. In particular duplicate privileges are removed. In
          the example above winnowing would leaves us with the
          following privileges:
          <artwork>    
            ReadAll
            DelExp
            AddArt
          </artwork>
        </t>
        <t>
          As can be seen, all the privileges left in the example
          above after winnowing are disjoint. The set is irreducible.
        </t>
        <t>
          Note also that the system doesn't care what the tree looks
          like. The same result would be gotten with the following
          tree, among others:

          <artwork>    
            ReadAll                      
            |
            |--DelExp
            |
            |--AddExp
            |  
            |--EditArt
            |  
            |--AddArt
          </artwork>
          [NOTE: MrB: This is somewhat counterintuitive. I would expect the shape of
          the tree to have influence. I understand it technically doesn't, but by 
          representing it as a tree the user expects AddExp to be "a part of" DelExp, 
          whatever that means to him. The difference between "defining" the tree and
          "checking the tree is a concept which is mentally merged for the user.]
        </t>
      </section>

      <section title="Assigning Privileges">
        <t>
          In order for the privileges system to do something useful,
          privileges need to apply for users and groups. This is done
          by assigning privileges to roles in the UI. Theoretically
          any privilege can be assigned to any role.
        </t>
        <t>
          Suppose I have a role FOO and the tree of privileges in the
          example above. The following operation:
        </t>
        <t>
          "assign ReadAll to FOO" [MrB: in abstract: assign [privilege] to [role], good example for adding a domain language for it later on]
        </t>
        <t>
          will assign all 5 of the privilege in the tree to
          FOO. (Note the notation for assignment shown here is only
          for convenience; the privileges UI is graphical)
        </t>
        <t>
          However, note that the operation:
        </t>
        <t>
          "assign DelExp to FOO"  
        </t>
        <t>
          will give a different result depending on the shape of the tree, as the following examples show:
          <artwork>    
            ReadAll                  "assign DelExp to FOO"
            |
            |--DelExp
            |                         Privileges assigned: DelExp
            |--AddExp                                      AddExp
               |                                           EditArt
               |--EditArt                                  AddArt
               |  
               |--AddArt
          </artwork>
          <artwork>    
            
            ReadAll                     "assign DelExp to FOO"                
            |
            |--DelExp                    Privileges assigned: DelExp
            |  |                                              AddExp
            |  |--AddExp
            |  
            |--EditArt
            |  
            |--AddArt
          </artwork>
        </t>
      </section>

      <section title="Default Assignments">
        <t>
          For convenience a number of assignments are made at
          initialization time. These cannot be changed.
        </t>
        <t> 
          The role "Everybody" is assigned the privilege
          "NoPrivileges". In other words, Everybody can do nothing.
        </t>
        <t> 
          Open Issue: should Everybody be assigned a higher
          privileges level, such as ACCESS_OVERVIEW?
          [MrB: no, not by the system, but maybe in the deployment]
        </t>
        <t> 
          The role Oversight is assigned the privilege
          FullPrivileges. In other words, members of the Oversight
          group can do anything.
        </t>
      </section>

      <section title="Inheriting Privileges">
        <t> 
          A privilege assigned to a role is automatically inherited
          by all the role's descendants. For example, using the previous
          example:
          <artwork>    
            ReadAll                   "assign ReadAll to FOO"
            |
            |--DelExp
            |  |                       Privileges assigned: DelExp
            |  |--AddExp                                    AddExp
            |                                               EditArt
            |--EditArt                                      AddArt
            |  
            |--AddArt
          </artwork>
          Role FOO will have 5 privileges assigned to him. However the
          same privileges will also be assigned to a child of FOO:
          <artwork>    
            FOO                     
            |
            |--BAR
          </artwork>
          We say that BAR has inherited the privileges of FOO. Note
          that BAR may also have privileges assigned to it. The UI
          of the privileges system will show for each role which
          privileges have been assigned and which inherited.
        </t>
        <t> 
          It's pretty apparent that if an inherited and an assigned
          privilege are disjoint, then nothing will happen. Essentially
          the two privileges have nothing to do with each other. But
          what happens when one of them implies the other? To wit:
          
          <artwork>    
            FOO                 has assigned DelExp                
            |
            |--BAR              has assigned ReadExp
            
            where
            
            Name     Realm     Module    Component    Instance    Level
            -------- --------- --------- ------------ ----------- ------------
            2. DelExp   All       Examples  All          All         ACCESS_DELETE    
            3. ReadExp  All       Examples  All          All         ACCESS_READ    
          </artwork>
          
          In this case the relevant privilege for BAR would be
          ReadExp, even though its access level is lower, because
        </t>
        <t> 
          Rule: For privileges that are not disjoint, those of the
          children take precendence over those of the parents. We say
          that BAR's privilege "trumps" that of his parent FOO.
        </t>
      </section>

      <section title="Masks">
        <t> 
          A mask is a special type of
          privilege in the Xaraya security system. Each mask
          refers to one or more security checks in the code. When a
          security check is encountered, the system gets the relevant
          mask and compares it to the privileges of the user. A green
          light is given if the mask is implied by one of the user's
          privileges. Otherwise an exception is thrown.
        </t>
        <t>	
          The structure of a Schema corresponds to that of a privilege. For example the following Schema
          <artwork>
            Name     Realm     Module    Component    Instance    Level
            -------- --------- --------- ------------ ----------- ------------
            ReadExp  All       Examples  All          All         ACCESS_READ    
          </artwork>
          requires that a user has a privilege assigned with at
          least ACCESS_READ in order to pass a given security check.
        </t>
      </section>

      <section title="How the System checks Privileges">
        <t> 
          When a security check is encountered in the code, the
          privileges system goes through the following steps:
          <list style="numbers">
            <t>
              It identifies the role encountering the check and gets
              all his ancestors.
            </t>
            <t>
              For each ancestor it creates an irreducible set by finding
              all the assigned privileges and winnowing them.
            </t>
            <t>
              Next, for each ancestor level the privileges inherited
              to the next level, where they are winnowed again, until the
              role is reached. The result of this process is an
              irreducible set of privileges specific to that role.
            </t>
            <t>
              In a final step the privileges of the set are compared
              ome by one against the Schema of the security. If any of
              the privileges implies the Schema, the security check is
              passed.
            </t>
          </list>
        </t>
        <t>
          In the following example:
          <artwork>
            
            Everybody           offspring distance 2 or 3
            |
            |--Marketing        offspring distance 1
            |  |
            |  |--Product Mgr
            |  
            |--Europe           offspring distance 2
               |
               |--Spain         offspring distance 1
                  |
                  |--Product Mgr
          </artwork>
          Let's assume the user logged in has the Product Mgr role and an action is
          requested by that user which is protected by the security system. Below are the 
          steps what happens. Look at this example from the point of view of the actual
          role requesting the protected action (here: Product Mgr). The offspring distance is
          the ancestry relative to Product Mgr (the maximum value for it)
          <list style="numbers">
            <t>
              The system gets the privileges of all ancestors of Product Mgr and
              winnows the privileges of each of them. In this case: Everybody, Marketing, Europe
              and Spain. The privileges of the role itself are also fetched and winnowed. The result is that each node in the tree now has its irreducuble set of privileges assigned to it.
            </t>
            <t>
              Next, each irreducible set is looked at, starting at the top level. (here:
              Everybody).
            </t>
            <t>
              The irreducible set is inherited by the offspring at the
              next distance. In this case "Europe" inherits the
              irreducible set of "Everybody". (3->2 inheritance), and "Marketing" also inherits the irreducible set of "Everybody" (2->1 inheritance).
            </t>
            <t>
              This process is repeated for the next distance level, so "Spain"
              inherits "Europe" (2->1)
            </t>
            <t>
              The "Spain" and "Marketing" privileges are then winnowed against each
              other (both are at distance 1)
            </t>
            <t>
              At this point we have the irreducible sets for distance 1, so we can continue
              to the requesting role. Product Mgr inherits the irreducable set from
              distance 1 (1->0) (which have been created from the irreducable sets from the 
              higher distances). This produces the irreducible set of privileges for the
              Product Mgr role.
            </t>
            <t>
              That set is compared against the mask of the security check needed for the
              requested action. If one of the privileges in the set implies the mask, the 
              check is passed and the user is granted to perform the action.
            </t>
          </list>
          You probably want to read the above again. ;-)
        </t>
        
      </section>
    </section>

    <section title="Architecture">
      <t>
        The privileges system is implemented through the following objects:</t>
      <section title="Roles">
        <t>
          A central repository of user and group definitions. Each
          user, group, group of groups etc. is a role with an entry in
          this repository.
        </t>
        <t>
          An implementation of the roles object
          conceptually replaces the tables xar_user and
          xar_groups. The code for manipulating roles will deal with
          the issue of whether the role is a group or a user and
          handle things accordingly.
          <artwork>
            Methods:    
            getroles           returns an array representing all the roles in the system.
            Note: should be private.
            getrole            returns a single role of type group based on its ID.
            Note: should be private.
            getsubroles        returns all the subgroups of a given role based on its ID.
            makeTree           returns a tree representation of the roles of type group.
            drawtree           returns a crude HTML drawing of a tree generated by maketree.
            Note: needs to be moved out to the templates.
            [MrB: use only two methods getRole and getRoles with a type parameter]
          </artwork>
        </t>
      </section>

      <section title="Masks">
        <t>
          A central repository of privilege masks (policies?). The
          masks are normally defined and registered as entries upon
          installation of a module. There needs to be a restriction
          that assigned names for components need to be unique within
          a module.
          
          <artwork>
            Methods:    
            listall            gets a list of all the mask entries
            getEntry           get a mask based on its id or its name
          </artwork>
        </t>
      </section>

      <section title="Privileges">
        <t>
          A central repository for privileges defined at any given
          time. No duplicate privileges are allowed.
          
          <artwork>
            Methods:    
            getprivileges     returns an array representing all the privileges in the system.
            Note: should be private.
            getprivilegefast  returns an array representing a single privilege  based on its ID.
            Note: should be private.
            getsubprivileges  returns all the child privileges of a given privilege  based on its ID.
            getmodules         returns an array of all the registered modules.
            Note: Move out? [MrB: use xarAPI function for this]
            getrealms          returns an array of all the registered realms.
            Note: Move out? [MrB: postpone]
            makeTree           returns a tree representation of the privileges.
            drawtree           returns a crude HTML drawing of a tree generated by maketree.
            Note: needs to be moved out to the templates.
          </artwork>
        </t>
      </section>

      <section title="Role">
        <t>
          An object representing a single group or user.
          
          <artwork>
            Methods:            
            constructor
            add               add this role to the Roles repository.
            remove            remove this role from the Roles repository.
            update            update this role in the Roles repository.
            addMember         add a child role to this role.
            removeMember      remove a child role from this role.
            getChildren       get an array representing the child roles of this role.
            getAllPrivileges  get an array representing all the privileges defined. 
            [MrB: maybe include in xarAPI]
            getPrivileges     get an array representing the privileges assinged to this role.
            [MrB: maybe include in xarAPI]
            getChildren       gets a list of the roles who are members of this role
            getParents        gets a list of the roles who this role is a member of
            getAncestors      recursive getParents
            getDescendants    recursive getChildren
            isMember          check whether a role is a member of this role
            isUser            check whether this role is a user
            isGroup           check whether this role is a group
            [MrB: consistency of interface]
            equals            check whether a role is the same as this role
            gets              all the interesting variables
            sets              all the interesting variables except the ID
            [MrB: maybe come up with a better method name for those two]
            assignPrivilege  assign a privilege to this role
            removePrivilege  remove a privilege from this role
            
            //Methods that are useful but have no bearing on the privileges problem.
            getInfo           get an information field of the role (user)
            setInfo           set an information field of the role (user)
            
          </artwork>
        </t>
      </section>

      <section title="Mask">
        <t>
          An object representing a single mask
          <artwork>
            Methods:            
            constructor            
            add            add this mask to the Masks repository
            remove         remove this mask from the Masks repository
            equals         check whether a role is the same as this role
            implies        check whether an entry implies this entry
            gets           all the interesting variables
            sets           all the interesting variables except the ID
            challenge      check the permisssions of a role
          </artwork>
        </t>
      </section>

      <section title="Privilege">
        <t>
          An object representing a single privilege. This extends Mask
          <artwork>
            Methods:            
            constructor
            add             add this privilege to the Privileges repository.
            remove          remove this privilege from the Privileges repository.
            update          update this privilege in the Privileges repository.
            addMember       add a child privilege to this privilege
            removeMember    remove a child privilege from this privilege
            getChildren     gets a list of the roles who are members of this role
            getParents      gets a list of the roles who this role is a member of
            getAncestors    recursive getParents
            getDescendants  recursive getChildren
          </artwork>
        </t>
      </section>

    </section>

    <section title="Database Tables">
      <section title="Roles Tables">
        <t>
          The tables xar_groups and xar_users can be merged into a new
          Roles table. The table xar_group_membership also changes:
          
          <artwork>
            Table xar_roles     Table xar_rolemembers
            xar_rid                    xar_rid
            xar_name                   xar_parentid
            xar_type
            xar_parent
            xar_uname
            xar_email
            xar_pass
            xar_url
            xar_auth_module
          </artwork>
          The field xar_type is 0 implies child is a user, 1 implies
          child is a group. Calls to groups and users in the API have
          to be appropriately modified to look up the new table.
          [MrB: evaluate whether we can use "implicit" typing. if(nochildren): user;else: group]
        </t>
      </section>

      <section title="Security masks Table">
        <t>
          <artwork>
            Table xar_securitymasks
            xar_mid
            xar_name
            xar_realm  [MrB: leave it for now, don't use it]
            xar_module 
            xar_component
            xar_instance
            xar_level
            xar_description
          </artwork>
        </t>
      </section>

      <section title="Privileges Table">
        <t>
          <artwork>
            Table xar_privileges      Table xar_permmembers
            xar_pid                    xar_pid
            xar_name                   xar_parentid
            xar_realm
            xar_module
            xar_component
            xar_instance
            xar_level
            xar_description
          </artwork>
        </t>
      </section>

      <section title="ACL Table">
        <t>
          <artwork>
            Table xar_acl
            xar_partid
            xar_privid
          </artwork>
        </t>
      </section>

    </section>
    
    <section title="Syntax">
      <t>
        The module developer needs to register each component
        in his module as a SecurityMask object. This is done by
        placing something like the following line in the xarinit.php
        file:
        
        <artwork>
          new xarSecurityMask(  "addadownload",      // what I'm going to call this mask
          0,                   // the realm [MrB: either don't use or force to 0]
          "AddDownload",       // the component
          "*",                 // the instance
          ACCESS_ADMIN,        // the threshold privilege level
          "admins only")       // an explanatory comment
        </artwork>
        Such a call can also be inserted when a new instance is
        created. This would let have the user define privileges at
        run time. (can of worms, here)
        [MrB: yeah, don't allow it initially till we have worked it out how exactly to do that]
        
        Checking a privilege is done with:
        <artwork>
        xarSecurityMasks.getEntry("addadownload").challenge();
        </artwork>

        Note in this call both the module and the role are implied,
        because we can get both during runtime. A more complete
        call would be:
        <artwork>
        xarSecurityMasks.getEntry("Downloads","addadownload").challenge($thisrole);
        </artwork>
        [MrB: can $thisrole have anothervalue then "the current role"?]
        
        To ensure backward compatibility we define something like:
        <artwork>
          function xarSecAuthAction($realm,$component,$instance,$level,$userid=NULL){
          //..preparatory stuff to find the right mask
          // if it doesn't exist we'll have to create it
          // IMPORTANT: need explode any regex...
          if (xarSecurityMasks.getEntry($mask).challenge()) {
          return true;
          }
          return false;
          }
        </artwork>
        Note there needs to be a translation layer which transforms
        any regular expressions in the call into masks compatible
        with what's in the xar_securitymasks table. Since this
        problem was implicitly solved in the current version of the
        privileges system I'm assuming we'll just borrow from that
        code.
        [MrB: work this out a bit more, not high prio in my opinion, but endusers prolly will challenge that ;-) ]
      </t>
    </section>

    <section title="Open Issues">
      <section title="Regex">
        <t>
          I'd rather dispense with this and run the UI through
          dropdowns and checkboxes, but I understand that some people
          are clamoring for an "advanced user" UI for the privileges
          system. There may also be some performance considerations
          here, trading CPU processing for DB hits. And then there's
          backwards compatibility. Well, OK.  
        </t>
        <t>
          My suggestion for the future would be to limit the advanced
          UI to entering lists into the appropriate form fields, say a
          "Component" or "Instance" field in the UI. On submitting,
          the list(s) would be disassembled to records in the
          privileges table with one component/instance per
          record. This in itself is not trivial, because the user
          would be entering some sort of name, and you'd have to parse
          the name, make sure it corrsponded to a real object
          registered in the privileges system, and then translate it
          to a numeric ID.
        </t>
      </section>

      <section title="Multi-language">
        <t>
          Need to check to make sure any calls using the name of an
          object rather than its ID don't screw up the ML capabilities.
        </t>
      </section>

      <section title="Realms">
        <t>
          Realms have been in the old security system, but no-one seems to 
          know exactly what they do and how to use them. Until that is crystal 
          clear, realms will not be supported, or rather, actively not supported. 
          We can't have loose ends in a security system
        </t>
      </section>

      <section title="Future Implementation">
        <t>
          The issues encountered in Version 1.0 suggest merging the
          Roles and Privileges modules into a single module in the
          future.
        </t>
        <t>
          A thourough evaluation needs to be done, whether we want 
          the security system in user module space. This has both advantages 
          and disadvantages. For ease of migration they will be in user module
          space for now, possibly classified as "Core Admin", so a reasonable 
          guarantee can be given they exist when bootstrapping the system.
        </t>
      </section>

      <section title="Miscellaneous Notes To Do">
        <t>
          <list style="symbols">
            <t>
              Need to integrate a regex translation layer for backward
              compatibility.
            </t>
            <t>
              We need to set up a quality assurance program in general for
              Xaraya, but specifically for security related issues. If we 
              ever want Xaraya to be used in corporate environments, this is
              a critical requirement.
            </t>
          </list>
        </t>
      </section>
    </section>
    <!-- Revision history is mandatory -->
    <section title="Revision history">
      <t>
        Version 0.9, Dec 15, 2002: First release of this document
      </t>
      <t>
        Version 1.0, Jan 15, 2003: Major rewrite based on the first
        version of the code. Clearer definition of the architecture,
        implementation and UI.
      </t>
      <t>
        Version 1.1, Feb. 8, 200: terminology changes, review by MrB
      </t>
    </section>
    
  </middle>
  
  <!-- Back matter is used for references and appendices which come after the references -->
  <back>
    <references title="Reference title">
      <!-- Fill in references as needed -->
      <reference>
        <front>
          <title>Reference title</title>
          <author>
            <organization>Organization</organization>
          </author>
          <date year="2002"/>
        </front>
      </reference>
      <!-- Repeat the aboven block if more references are needed -->
    </references>
    
    <!-- Any section after this will become an appendix -->
  </back>
</rfc>
