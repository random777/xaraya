<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xsl"?>
    <!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<!-- <?rfc private='my private memo'?>  Produce a private memo rather than a Xaraya-standard --> 
<?rfc toc="yes"?>

<rfc number="0035" category="std">
  <!-- number: Fill in the number for the RFC -->
  <!-- obsoletes: Comma separated list of RFC numbers which this one obsoletes -->
  <!-- category: std=standard, bcp=best common practice, info=info, exp=experimental, historic=historic -->

  <!-- Front matter is used for identification of author and organization -->
  <front>
    <title>Query Abstraction</title>
    <author initials="F.B." surname="Botelho" fullname="Flavio Borges Botelho">
      <organization>Xaraya Development Group</organization>
      <address>
        <email>nuncanada@ig.com.br</email>
        <uri>http://www.xaraya.com</uri>
      </address>
    </author>
    <date month="January" year="2003"/>
    
    <!-- Initiating team for this RFC -->
    <workgroup>Project Management Committee</workgroup>

    <!-- List keywords for the RFC here -->
    <keyword>SQL</keyword>
    <keyword>database</keyword>
    <keyword>query</keyword>
    <keyword>abstraction</keyword>

    <!-- The abstract summarizes in one or two paragraphs the content of the RFC -->
    <abstract>
      <t>
        This RFC presents a proposal for Query Abstraction inside Xaraya Architeture.
      </t>
    </abstract>
  </front>

  <!-- The middle section is used for the actual content of the RFC -->
  <middle>
    <!-- Introduction is mandatory -->
    <section title="Introduction">
      <t>
        Query Abastraction has been made necessary to give us the hability to generate
        efficient SQL queries which are portable across all our Database Pool. It will
        provide us a way to create queries without any preocupations about the
        underlying storage system.
      </t>
    </section>

    <section title="Pros">
      <t>
         "Allows for the creation of queries in a persistent storage neutral manner.
         Expressed as objects, queries remain consistent across multiple persistent
         storage solutions. Should the database change from RDB to an OODB " or even to
         XML Based Query Languages (A lot of research is being done in the field - References [3,4]),
         "no part of the application will need to be modified." - Reference [2]
      </t>
    </section>

    <section title="Requirements List">
      <t>
         The following is list for sugestions about the implementaion of the Query Abstraction.
         Please add your own.
      </t>
      <t>
      <list style="numbers">
        <t>Turn Xaraya completely database agnostic. [Main reason to be implementing this]</t>
        <t>As we already have a DB Abstraction Library (ADODB), this should be an extension of it. [Gary]</t>
        <t>Devs should be able to keep using their known SQL for simple queries, where portability is not
           a problem. [LadyofDragons]</t>
        <t>The query structure should be able to be passed around the program and receive input from
           many different modules. [Nuncanada]</t>
      </list>
        </t>
    </section>

    <section title="Possible Implementations Reasearch">
      <t>
         There just a few query abstraction packages for PHP, 2 found in the PEAR archives. Both
         have serious shortcomings to our needs (DB_DataObjects and DB_QueryTool).
         Both were made without taking in account the necessity to handle multiple DBs.
      </t>
      <t>
         Research done in other languages for inspiration has shown that most query abstractor out there
         have too simplistic approaches, mainly:
         <list style="numbers">
           <t>Simplistic - They simply support the most basic features of the SELECT query, where the own SQL
              language is already the basic abstraction.</t>
           <t>Placeholders - They simply store 'common' queries with wildcards showing where the input values
              should be added. Clearly this doesnt produce DB independent SQL. </t>
           <t>Stored queries - They store the DB-specific query in files to be called, would be a similar system
              to that of using our MLS system to translate SQL queries to a specific DB dialect.
              This requires you to know how to implement the query in every DB, and although it is able to
              support more complex queries than the simplitic approach. It is not able to translate
              dynamic queries.</t>
          </list>
          
          So there are two possible implementaions:
         <list style="numbers">
           <t>Stored queries - It's not able to translate dynamic queries. And it will probably create
              bigger problems than translations themselves (as i think it is easier to find a translator than
              a DB specialist). Requiring that the Mod Dev himself creates the translation to all possible DBs
              doesnt seem like a good idea.</t>
           <t>OO Query Abstraction - The good part is that it can implement all our requirements and could
              be a link towards future storage systems. Still it will obligate Mod Devs to learn it (for
              more complex queries) instead of using the well known SQL.</t>
          </list>
      </t>
    </section>

    <section title="Implementation Idea">
      <t>The following is where the proposed implementation itself is shown</t>
      <t>
         There should be two separate concepts, that of the query structure which preferebly would
         be a class used only to hold the devs wishes, and drivers to take this annotated wish list
         and transform it into a proper query.
      </t>
      <t> The basic idea is a simple one, you will have a class (our query abstraction class) which
          will *hold* (with pointers, creating a rigid structure of relations) what the developer
          is trying to achieve.
          Then when he thinks he already has everything he wants in the 'shopping list', this
          structured list will be passed over to a specific DB driver which will translate the given
          structure in the best possible query for the developer.
       </t>
    </section>


    <section title="Concept of how the query abstraction would be used">
      <t> How would it work:
        <artwork>
    This would work if there was data present in the xartables.php informing us what are the tables,
    their fields, their foreign keys with the nature of the relationship (1-1, 1-Many, Many-Many,
    what to do with missing values on one side and/or the other?)

    $query =&#38; new sql_select;
    $query-&#62;select('name','description','left','right');
    $result =&#38; $query-&#62;run();

    Assuming there is a 1-1 relationship between users and their groups, in two separated tables
    and that this is properly set in the xartables.php
    $query =&#38; new sql_select;
    $query-&#62;select('username','groupname');
    $result =&#38; $query-&#62;run();

    {Now on omitting $query =&#38; new sql_select; }

    You would be able to do any query including joins that easily unless there were conflicting field names
    then you would have to set their respective tables:

    Suppose there is an alias field in the user table and a alias in the groups table
    This way the bulder won´t know which alias to choose

    $query-&#62;select('username','groupname','alias');


    Right now i am thinking about this:

    $field =&#38; $query-&#62;create('field','alias');
    $field-&#62;table('groups');
    $query-&#62;select('username','groupname', $field);

    But can be changed to other syntaxes:  (After writing, i think this one seems better)

    $field =&#38; $query-&#62;field('alias', 'groups');
    $query-&#62;select('username','groupname', $field);

    Or:
    $field =&#38; $query-&#62;field('alias');
    $field-&#62;table('groups');
    $query-&#62;select('username','groupname', $field);

    Which one is the best? Please comment!!!!

    Now the part where i havent found a better way of doing the syntax:
    It is simple, but a lot of nested code...

    $query-&#62;where($query-&#62;condition('userid','&#62;','1000'));

    So, something like this:
    "SELECT
            COUNT(P2.".$categoriescolumn['cid'].") AS indent,
            P1.".$categoriescolumn['cid'].",
            P1.".$categoriescolumn['name'].",
            P1.".$categoriescolumn['description'].",
            P1.".$categoriescolumn['image'].",
            P1.".$categoriescolumn['parent'].",
            P1.".$categoriescolumn['left'].",
            P1.".$categoriescolumn['right']."
       FROM $categoriestable AS P1,
            $categoriestable AS P2
      WHERE P1.".$categoriescolumn['left']."
            &#62;= P2.".$categoriescolumn['left']."
        AND P1.".$categoriescolumn['left']."
            &#60;= P2.".$categoriescolumn['right'];"

    Would be something like:

    $P1 = $query-&#62;table('categories','P1');
    $P2 = $query-&#62;table('categories','P2');
    $query-&#62;select(
        $query-&#62;function('COUNT',$query-&#62;field('cid',$P2),'indent'),
        $query-&#62;field('cid',$P1),
        $query-&#62;field('name',$P1),
        $query-&#62;field('description',$P1),
        $query-&#62;field('image',$P1),
        $query-&#62;field('parent',$P1),
        $query-&#62;field('left',$P1),
        $query-&#62;field('right',$P1));

    $query-&#62;where(
        $query-&#62;condition(
            $query-&#62;condition($query-&#62;field('left',$P1),'&#62;=',$query-&#62;field('left',$P2)),
            'AND',
            $query-&#62;condition($query-&#62;field('right',$P1),'&#60;=',$query-&#62;field('right',$P2))));


    Comment!

        </artwork>
      </t>
    </section>

    <section title="Concept sketch of the proposed code">
      <t> Sketch of the proposed code:
        <artwork>
/* 5 basic SQL structure types: alias, table, field, function, condition
 * Special structures: CASE, USER_VARIABLE???
 */


// 3 very simple equal (if werent for the hierarchy) classes...
// Leaving like this for now, as it helps understand what is the idea.
// get_class($object) == 'sql_alias'


class sql_alias {
    var $alias;
    //Constructor
    function sql_alias ($alias) {$this-&#62;alias = $alias;}
    function get_alias () {return $this-&#62;alias;}
}

class sql_table extends sql_alias {
    var $table;
    //Constructor
    function sql_table ($table, $alias = NULL) {
        $this-&#62;table = $table;
        if ($alias !== null) {
            $this-&#62;sql_alias($alias);
        }
    }
}

class sql_field extends sql_table {
    var $field;
    //Constructor
    function sql_field ($field, $table = NULL, $alias = NULL) {
        $this-&#62;field = $field;
        if ($table !== null) {
            $this-&#62;sql_table($table);
        }
        if ($alias !== null) {
            $this-&#62;sql_alias($alias);
        }
    }
    function get_field () {return $this-&#62;field;}
}

class sql_function extends sql_alias{
    //Functions: SUM, AVG, COUNT, MIN, MAX, LIKE, NOT, any other??
    var $function;
    //Points to a sql structure (field, function or condition)
    var $pointer;
    function sql_function ($function, $pointer, $alias = NULL) {
        $this-&#62;function = $function;
        $this-&#62;pointer = $pointer;
        if ($alias !== null) {
            $this-&#62;sql_alias($alias);
        }

    }
    function get_function () {
        return Array('function' =&#62; $this-&#62;function, 'pointer' =&#62; $this-&#62;pointer);
    }
}

class sql_condition
{
    //Points to a sql structure (field, function or another condition))
    var $pointer1, $pointer2;
    //Connectives: +, -, /, *, =, &#62;, &#60;, &#60;=, &#62;=, any other??
    var $connective;
    function sql_condition ($pointer1, $connective, $pointer2) {
        $this-&#62;pointer1 = $pointer1;
        $this-&#62;pointer2 = $pointer2;
        $this-&#62;connective = $connective;
    }
    function get_condition () {
        return Array('pointer1' =&#62; $this-&#62;pointer1, 'pointer2' =&#62; $this-&#62;pointer2, 'connective'=&#62;$this-&#62;connective);
    }
}

    // Should CASE (or DECODE or iff) be considered a function? No! It is a special case
    // I think it maybe the case for having a special function (as i think ADODB will have
    // such a function sooner or later)
    //Use Example : SELECT a.ManagerName, SUM(CASE WHEN b.Approval='Y' THEN 1 ELSE 0 END) as Y,
class sql_case
{
    var $case = Array ();
    function add_case ($when, $then, $else) {
        $case[] = Array ('when' =&#62; $when, 'then' =&#62; $then, 'else' =&#62; $else);
    }
}


// sql_connective or sql_operator?
// class sql_connective {}
//  Dont think it is necessary... They are considered strings...

/**
 * Helper Class to mount a SQL Select Query
 * It´s a little more than a struct, keeping the different 'areas' from
 * the Select Query separated. So tables, fields and join statements can be
 * easily exchanged between different parts of the code.
 */
class SQL_SELECT
{
    var $areas = Array ('select'  =&#62; Array(),
                        'from'    =&#62; Array(),
                        'join'    =&#62; Array(),
                        'where'   =&#62; NULL,
                        'groupby' =&#62; Array(),
                        'having'  =&#62; NULL,
                        'orderby' =&#62; Array(),
                        'limit'   =&#62; Array('nrows'=&#62;null,'offset'=&#62;null),
                        'options' =&#62; Array());

    function checkNotTable (&#38;$input) {
        // check('field') needs to be the first, as fields are the standard input
        if (!$this-&#62;check('field',$input)     &#38;&#38;
            !$this-&#62;check('function',$input)  &#38;&#38;
            !$this-&#62;check('condition',$input) &#38;&#38;
            !$this-&#62;check('case',$input)) {
            return false; //Error
        }
        return true;
    }

    function &#38;condition ($pointer1, $connective, $pointer2) {
        if ($this-&#62;checkNotTable($pointer1)) {
            die ('Pointer1 is not a field, function or condition');
            return; //Error
        }

        if ($this-&#62;checkNotTable($pointer2)) {
            die ('Pointer2 is not a field, function or condition');
            return; //Error
        }

        $obj =&#38; new sql_condition ($pointer1, $connective, $pointer2);

        return $obj;
    }

    function &#38;function ($function, $pointer) {
        if ($this-&#62;checkNotTable($pointer)) {
            die ('Pointer is not a field, function or condition');
            return; //Error
        }

        $obj =&#38; new sql_function ($function, $pointer);

        return $obj;

    }

    function &#38;case ()
        if ((func_num_args()%3)!=0) {die('Case can only be assigned in triples : WHEN THEN ELSE');}
        $args = func_get_args();

        $obj =&#38; new sql_case ();

        for ($i=0;$i+=3;$i&#60;func_num_args()) {
            $obj-&#62;add_case($args[$i], $args[$i+1], $args[$i+2]);
        }

        return $obj;
    }

    /**
    * Adds to the SELECT structure
    *
    * @param string Where in the structure you want to add it? (select, from, join, where, groupby, having, orderby)
    *               SELECT ... FROM ... JOIN ... WHERE ... GROUPBY ... HABING ... ORDERBY
    *               This was made this way to make it easier to understand how to use it
    * @params mixed The rest of the parameters depend on the chosen place of structure you´re adding to:
    *               SELECT  -&#62; any number of fields
    *               FROM    -&#62; any number of tables
    *               JOIN    -&#62; $table, $on, $jointype
    *               WHERE   -&#62; 1 condition
    *               GROUPBY -&#62; any number of fields
    *               HAVING  -&#62; 1 condition
    *               ORDERBY -&#62; any number of fields
    *
    * @author Nuncanada
    * @access public
    */
/*
 *
 * Can be done both ways :
    As $query-&#62;add('select'....)
    Or $query-&#62;select(...);
    The 2nd seems more natural for us SQL zombies
    function add () {
        $args = func_get_args();
        if (func_num_args()&#62;0) {

            $case = strtolower(array_shift($args));

            switch($case) {
                case 'select':
                    foreach ($args as $arg) {
                        if ($this-&#62;checkNotTable($arg)) {
                            return; //Error
                        }
                    }

                    $this-&#62;areas[$case] = array_merge($this-&#62;areas[$case], $args);
                    break;


                case 'groupby':
                case 'orderby':
                    foreach ($args as $arg) {
                        if (!$this-&#62;check('field',$arg)) {
                            return; //Error
                        }
                    }

                    $this-&#62;areas[$case] = array_merge($this-&#62;areas[$case], $args);
                    break;

                case 'from':
                    foreach ($args as $arg) {
                        if ($this-&#62;check ('table',$arg)) {return;};
                    }

                    $this-&#62;areas[$case] = array_merge($this-&#62;areas[$case], $args);
                    break;

                case 'join':
                    if (count($args)!= 3) {die('Wrong parameter count. Where and Having can only have 1 condition parameter');}
                    if (!$this-&#62;check ('table', $args[0])) {return;}
                    if (!$this-&#62;check ('condition', $args[1]) {return;}

                    $this-&#62;areas['join'][] = Array('table' =&#62; $args[0],
                                                   'condition' =&#62; $args[1],
                                                   'joinType' =&#62; $args[2]);

                    break;

                case 'where':
                case 'having':
                    if (count($args)!=1) {die('Wrong parameter count. Where and Having can only have 1 condition parameter');}
                    if (!$this-&#62;check('condition', $args[0]) {return;} //Error

                    $this-&#62;areas[$case] = $args[0];
                    break;

                default:
                    die('Unknown Area in the query'); //Error
                    break;
            }
        } else {
            die('Nothing to add');
        }
    }
  */
    var $select = Array();
    function select () {
        $args = func_get_args();
        foreach ($args as $arg) {
            if ($this-&#62;checkNotTable($arg)) {
                return; //Error
            }
        }
        $this-&#62;select = array_merge($this-&#62;select, $args);
    }

    var $groupby;
    function groupby () {
        $args = func_get_args();
        foreach ($args as $arg) {
            if (!$this-&#62;check('field',$arg)) {
                return; //Error
            }
        }
        $this-&#62;groupby = array_merge($this-&#62;groupby, $args);
    }

    var $orderby = Array();
    function orderby () {
        $args = func_get_args();
        foreach ($args as $arg) {
            if (!$this-&#62;check('field',$arg)) {
                return; //Error
            }
        }
        $this-&#62;orderby = array_merge($this-&#62;orderby, $args);
    }

    var $from = Array();
    function from () {
        $args = func_get_args();
        foreach ($args as $arg) {
            if (!$this-&#62;check('table',$arg)) {
                return; //Error
            }
        }
        $this-&#62;from = array_merge($this-&#62;from, $args);
    }

    var $join = Array();
    function join ($table, $condition, $joinType = '') {
        if (!$this-&#62;check ('table', $table)) {return;}
        if (!$this-&#62;check ('condition', $condition) {return;}
        $this-&#62;join[] = Array('table' =&#62; $table, 'condition' =&#62; $condition, 'joinType' =&#62; $joinType);
    }

    var $where = NULL;
    function where ($condition) {
        if ($this-&#62;where != NULL) {
            die('Where condition already set');
        }
        if (!$this-&#62;check('condition', $condition) {return;} //Error
        $this-&#62;where = $condition
    }

    var $having = NULL;
    function having ($condition) {
        if ($this-&#62;having != NULL) {
            die('Where condition already set');
        }
        if (!$this-&#62;check('condition', $condition) {return;} //Error
        $this-&#62;having = $condition
    }

    /**
    *   Adds one option to the SELECT syntax. ie DISTINCT
    *
    * @param string Select Option
    * @author Nuncanada
    * @access public
    */
    function addOption($option)
    {
        // Examples: DISTINCT, etc etc
        $this-&#62;areas['options'] = $option;
    }

    /**
    * Sets a Limit to the SELECT
    *
    * @param integer Number of rows
    * @param integer Starting Number
    * @author Nuncanada
    * @access public
    */
    function limit($nrows, $offset)
    {
        $this-&#62;areas['limit'] = array('nrows'=&#62;$nrows,'offset'=&#62;$offset);
    }

    /**
    * Check if an input is of the desired structure
    * If it is a string/int, then turn it into one object that represents the desired structure.
    *
    * @param string SQL structure
    * @param mixed User input - String or object
    * @author Nuncanada
    * @access private
    */
    function check ($structure, &#38;$input) {
        if (!is_object($input)) { //String or int

            //As this is a private function, this is just a reminder for myself while prototyping/testing
            if ($structure == 'condition' || $structure == 'function') {
                die ('Conditional or Functional statements cannot be input as strings.
                      They need their proper encapsulation'); // Error - Call Exceptions
                return;
            } else {
                $input = &#38;$this-&#62;create($structure, $input);
            }
        } elseif (get_class($structure) != 'sql_'.$structure) {
            return false;
        }

        return true;
    }

    /**
    * Creates the desired structure, return it as an object
    *
    * @param string $structure sql structure: 'alias', 'table', 'field', 'function'
    * @return mixed a newly created SQL structure object, or NULL
    * @author Chuck Hagenbuch
    * @access private
    */
    function &#38;create ($structure, $input) {
        $classname = "sql_${structure}";

        if (!class_exists($classname)) {
            return;            //Call Exception
        }

        $obj =&#38; new $classname ($input);

        return $obj;
    }

    /**
    * Get the strings present in a given place in the SQL structure
    * Will be used only by the DB drivers
    *
    * @param string Place in the SQL structure (from, join, where, groupby, having, orderby)
    * @author Nuncanada
    * $access private
    */
    function get ($area)
    {
        return $this-&#62;areas[$area];
    }
}


class SQL_SELECT_MYSQL extends SQL_SELECT
{
    var $intro = Array ('select'  =&#62; 'SELECT ',
                        'from'    =&#62; ' FROM ',
                        'join'    =&#62; ' ',
                        'where'   =&#62; ' WHERE ',
                        'groupby' =&#62; ' GROUP BY ',
                        'having'  =&#62; ' HAVING ',
                        'orderby' =&#62; ' ORDER BY ',
                        'limit'   =&#62; ' LIMIT ');


    function buildQuery ()
    {
        $query = '';
/*  To be done
        foreach ($this-&#62;areas as $area =&#62; $array)
        {
            if (count($array)&#62;0)
            {
                $string = '';

                switch ($area)
                {
                    case 'select':
                    case 'from':
                    case 'groupby':
                    case 'orderby':
                        $string = implode(', ', $array);
                        break;
                    case 'join':
                        $string = implode(' ', $array);
                        break;
                    case 'where':
                    case 'having':
                        $string = implode(' AND ', $array);
                        break;
                    default:
                        $string = 'Unknown Area in the query';
                        break;
                }
                $query .= $this-&#62;intro[$area] . $string;
            }
        }
*/
        return $query;
    }
}

        </artwork>
      </t>
    </section>
  </middle>

  <!-- Back matter is used for references and appendices which come after the references -->
  <back>
    <references title="Relevant References">

      <reference target="http://www.ling.uni-potsdam.de/~moocow/projects/diplom/html-plain/node1.html">
        <front>
          <title>relational query feature structures</title>
          <author initials="B" surname="Jurish" fullname="Bryan Jurish">
            <organization></organization>
          </author>
          <date year="2001"/>
          <note title="earlier implementation in perl">
            <t>
              He tried to do what we want in Perl. Still to achive that he only made possible simple queries,
              where the Standard SQL is already the de facto needed abstraction.
            </t>
          </note>
        </front>
      </reference>

      <reference target="http://www.objectwave.com/pdf/tools/JGrinder.pdf">
        <front>
          <title>ObjectWave JGrinder</title>
          <author initials="" surname="" fullname="">
            <organization>ObjectWave</organization>
          </author>
          <date year="2002"/>
          <note title="Proprietary Java implementation without much technical detail (vaporware?)">
            <t>
            </t>
          </note>
        </front>
      </reference>

      <reference target="http://cobase-www.cs.ucla.edu/tech-docs/cqa.ps">
        <front>
          <title>CoBase: A Cooperative Database System</title>
          <author initials="W." surname="Chu" fullname="Wesley W. Chu">
            <organization>Computer Science Department University of California, Los Angeles</organization>
          </author>
          <author initials="Q." surname="Chen" fullname="Qiming Chen">
            <organization>Computer Science Department University of California, Los Angeles</organization>
          </author>
          <author initials="M." surname="Merzbacher" fullname="Matthew Merzbacher">
            <organization>Computer Science Department University of California, Los Angeles</organization>
          </author>
          <date year="2002"/>
          <note title="Cooperative Database System">
            <t>
                How having queries abstracted might help us communicate with future technology. We could
                create a CSQL driver for instance.
            </t>
          </note>
        </front>
      </reference>

      <reference target="http://arxiv.org/abs/cs.db/0110044">
        <front>
          <title>EquiX--A Search and Query Language for XML</title>
          <author initials="S" surname="Cohen" fullname="Sara Cohen">
            <organization></organization>
          </author>
          <author initials="Y" surname="Kanza" fullname="Yaron Kanza">
            <organization></organization>
          </author>
          <author initials="Y" surname="Kogan" fullname="Yakov Kogan">
            <organization></organization>
          </author>
          <author initials="W" surname="Werner" fullname="Werner Nutt">
            <organization></organization>
          </author>
          <author initials="A" surname="Serebrenik" fullname="Alexander Serebrenik">
            <organization></organization>
          </author>
          <author initials="Y" surname="Sagiv" fullname="Yehoshua Sagiv">
            <organization></organization>
          </author>
          <date year="2003"/>
        <note title="proxy database">
          <t>
          </t>
        </note>
        </front>
      </reference>

      <reference target="http://www.cs.duke.edu/~junyi/cps216/report.pdf">
        <front>
          <title>An Approach Towards Web Caching and Prefetching for Database Management Systems</title>
          <author initials="D" surname="Wang" fullname="Dazhi Wang">
            <organization>??</organization>
          </author>
          <author initials="J" surname="Xie" fullname="Junyi Xie">
            <organization>??</organization>
          </author>
          <date year="2003"/>
          <note title="proxy database">
            <t>
              Although the research is towards a proxy for the database system, our query abstraction
              could be able to modularly inform supposed proxies our query pattern / structure
              for better query prediction.
            </t>
          </note>
        </front>
      </reference>

      <reference target="http://arxiv.org/ftp/cs/papers/0301/0301009.pdf">
        <front>
          <title>A Script Language for Data Integration in Database</title>
          <author fullname="Qingguo Zheng">
            <organization>National Lab. of Software Development Enviroment, Beihang University</organization>
          </author>
          <date year="2003"/>
          <note title="script language">
            <t>
                Script Language as a query abstraction.
            </t>
          </note>
        </front>
      </reference>

      <reference target="http://marc.theaimsgroup.com/?l=php-dev&#38;m=101753543913458&#38;w=2">
        <front>
          <title>Relevant discussion about query abstraction</title>
          <author fullname="Daniel Lorch">
            <organization>PHP Devs</organization>
          </author>
          <date year="2002"/>
        </front>
      </reference>

      <reference target="http://marc.theaimsgroup.com/?l=php-dev&#38;m=101752997709709&#38;w=2">
        <front>
          <title>Relevant discussion about query abstraction</title>
          <author fullname="Stig">
            <organization>PHP Devs</organization>
          </author>
          <date year="2002"/>
        </front>
      </reference>

      <reference target="http://marc.theaimsgroup.com/?l=php-dev&#38;m=101740330610221&#38;w=2">
        <front>
          <title>Relevant discussion about query abstraction</title>
          <author fullname="Daniel Lorch">
            <organization>PHP Devs</organization>
          </author>
          <date year="2002"/>
        </front>
      </reference>

      <reference target="http://marc.theaimsgroup.com/?l=php-db&#38;m=100635358202596&#38;w=2">
        <front>
          <title>PHP dev stating that a SQL parser should be the solution</title>
          <author fullname="Tomas V. V. Cox">
            <organization>PHP Devs</organization>
          </author>
          <date year="2002"/>
          <note title="parsing">
            <t>
              I personally think parsing SQL is the wrong way to do it.
              There are too many inconsistent ways to do it, not to say it would be an unnecessary complex solution.
            </t>
          </note>
        </front>
      </reference>

      <reference target="http://pear.php.net/package-info.php?pacid=80&#38;release=0.13&#38;PHPSESSID=18e4b1d53db182aceeeb2c1e0b92e399">
        <front>
          <title>PEAR Package Data Object (for query abstraction)</title>
          <author fullname="">
            <organization></organization>
          </author>
          <date year="2002"/>
          <note title="class badly implemented">
            <t>
              The class doesnt fullfill our needs. Still there are things that can be reused.
            </t>
          </note>
        </front>
      </reference>

      <reference target="http://px.sklar.com/code.html?id=239">
        <front>
          <title>SubSelect Emulation for Mysql</title>
          <author fullname="">
            <organization></organization>
          </author>
          <date year="2002"/>
          <note title="should have this feature">
            <t>
              This is one of the features our query abstraction should have. It shows how the abstraction
              can add value to the overall solution. Metabase implements it too.
            </t>
          </note>
        </front>
      </reference>

      <reference target="http://www.oreilly.com/news/sqlnut_1200.html">
        <front>
          <title>Article showing difference between db queries</title>
          <author fullname="">
            <organization></organization>
          </author>
          <date year="2002"/>
          <note title="helpful article">
            <t>helpful for writing the drivers</t>
          </note>
        </front>
      </reference>


    </references>
    
    <!-- Any section after this will become an appendix -->
    <section title="Example appendix">
      <t>Any section which is present after the references will become an appendix</t>
    </section>
  </back>
</rfc>
