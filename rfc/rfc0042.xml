<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xsl"?>
    <!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<!-- 
    Supported processing instructions, uncomment the ones you want
-->

<!-- <?rfc private="my private memo"?>  Produce a private memo rather than a Xaraya-standard --> 
<!-- <?rfc editing="yes"?>  Insert a number in each paragraph to ease review comments -->
<!-- <?rfc symrefs="yes"?>  Instead of numeric cross references, use the sections name -->
<!-- <?rfc sortrefs="yes"?> Sort the references -->
<!-- <?rfc parse-xml-in-artwork="yes" ?> Do we want xml is artwork sections parsed (only uncomment if you know what that means) -->
<!-- <?rfc tocdepth="2"?>  How many levels should be displayed in the TOC (default: 99 -->

<!-- I guess we always want a table of contents -->
<?rfc toc="yes"?>
<?rfc editing="yes"?>

<rfc xmlns:ed="http://greenbytes.de/2002/rfcedit" number="0042" category="bcp">
  <!-- number: Fill in the number for the RFC -->
  <!-- obsoletes: Comma separated list of RFC numbers which this one obsoletes -->
  <!-- category: std=standard, bcp=best common practice, info=info, exp=experimental, historic=historic -->
  
  <!-- Front matter is used for identification of author and organization -->
  <front>
    <title>Module hooks system</title>
    <author initials="M.R." surname="van der Boom" fullname="Marcel van der Boom">
      <organization>Xaraya Development Group</organization>
      <address>
        <email>marcel@hsdev.com</email>
        <uri>http://www.xaraya.com</uri>
      </address>
    </author>
    <date month="Februari" year="2003"/>
    
    <!-- Initiating team for this RFC -->
    <workgroup>Project Management Committee</workgroup>
    
    <!-- List keywords for the RFC here -->
    <keyword>rfc</keyword>
    <keyword>template</keyword>
    
    <!-- The abstract summarizes in one or two paragraphs the content of the RFC -->
    <abstract>
      <t>This RFC documents the hooks system for Xaraya. We have a hooks system in place, but
        undocumented. This RFC should resolve that by at least documenting what we have now.
      </t>
    </abstract>
  </front>
  
  <!-- The middle section is used for the actual content of the RFC -->
  <middle>
    <!-- Introduction is mandatory -->
    <section title="Introduction">
        <t>The hook system allows site administrators to extend the functionality of modules - with
           common features like comments, hitcounts, ratings, support for BBCode or Wiki etc.</t>
        <t>Those features are provided by so-called hook modules : utility modules that offer a
           number of hook functions, that will be called automatically when the corresponding hooks are enabled.</t>
        <t>The main difference between hook calls and regular API calls is that hook calls to a
           particular hook function (e.g. to display comments) are not hard-coded in the module
           itself, but you can turn them on and off again via the administration.</t>
        <t>This gives you a much greater flexibility, both as a site administrator and as a module
           developer, in terms of the optional features that you want to provide in different parts
           of your site or in your module.</t>
    </section>

    <!-- One content section is mandatory -->
    <section title="Types of hooks">
        <t>There are 5 main types of hooks that are currently used to extend module functionality, plus some special-purpose hooks.
           Some hooks will provide part of the graphical user interface (GUI) to the user, while others will only operate on the API level.</t>

            <section title="Item Transform Hooks (API)">
                <t>This type of hook allows you to transform some pieces of text of your module items
                   (e.g. the summary and body of articles, or the description of a project, ...)
                   in different ways, depending on the hook modules that are enabled for it.
                   Hook modules that provide this type of hooks are for instance bbcode, autolinks, wiki, ...</t>
            </section>
            <section title="Item Display Hooks (GUI)">
                <t>This type of hook shows some additional information that relates to a particular
                   module item when that item is being displayed. Typical examples include comments, hitcount, ratings, ...</t>
            </section>
            <section title="Item Create/Update/Delete Hooks (API)">
                <t>Some hook modules follow the whole life cycle of module items, from the moment the item is created,
                   through any updates it may have, and up to the point where the item is deleted again.</t>
                <t>In some cases, like the hitcount or ratings module, those hooks are only used to keep track of some
                   internal value for each module item. In other cases, like for categories and dynamicdata, the hook
                   module will also provide a graphical interface - see next type of hook.</t>
            </section>
            <section title="Item New/Modify Hooks (GUI)">
                <t>This type of hook extends the previous one by showing some additional input fields in forms where module
                   items are added or modified. This allows you to e.g. assign a module item to a particular category,
                   or to fill in some dynamic properties for that item, etc.</t>
                <t>The corresponding values will then be saved or updated when the item is created/updated.</t>
            </section>
            <section title="Module Configuration Hooks (GUI/API)">
                <t>Some hook modules, like categories and dynamicdata, also offer specific configuration options
                   for each module that is hooked to them. This type of hook will automatically insert those options
                   within the rest of the module configuration screen, and update them when the module configuration itself is being updated.</t>
            </section>
            <section title="Special-Purpose Hooks : Search, UserMenu, WaitingContent, ...">
                <t>All the hook types described above provide some common add-on features that can be used to extend different modules.
                   So a utility module like autolinks, that provides an Item Transform hook, can be used by any module that calls the standard Item Transform hooks, e.g. in articles, xproject, xarbb, ...</t>
                <t>There is another type of hooks that works the other way around : those hooks are only called in one particular place, by one particular module,
                   and other modules that provide this hook function will only extend this particular functionality.</t>
                <t>One example of this is the Item Search hook, which is used by the search module to call any hook function (from any module) that provides a search interface.
                   So the articles module may provide a search hook function, and the xarbb module may provide one, and the roles module as well, and it's up to the site administrator
                   to decide which search functions he wants to allow by enabling the corresponding hooks.</t>
                <t>Another example is the UserMenu hook, which is used by the roles module to call any hook function that provides a user menu, for integration in "Your Account".
                   So the articles module may provide a user menu function, and the xarbb module may provide one, and the roles module as well, and it's up to the site administrator
                   to decide which user menu functions he wants to allow by enabling the corresponding hooks.</t>
                <t>The WaitingContent hook is another example, which is used by the adminpanels module to call any hook function that provides a list of waiting content, for use in the waitingcontent block.
                   So the articles module may provide a list of waiting content, and the xarbb module may provide one, and the polls module as well, and it's up to the site administrator
                   to decide which waiting content he wants to see by enabling the corresponding hooks.</t>
                <t>The Module Remove hook functions are called by Xaraya when a particular module is being removed, so that hook modules can perform some clean-up of their own table(s) if necessary.</t>
            </section>
    </section>
    
    <section title="Enabling or disabling hooks">
        <t>Site administrators can enable hooks via the Modules administration :
           <list style="symbols">
           <t>if you want to enable some hooks for a particular module (e.g. articles), you can do that via Modules -&gt; View All -&gt; extend that particular module</t>
           <t>if on the other hand, you want to enable/disable a particular hook (e.g. comments) for several modules at once (e.g. articles, example, polls, ...), you should do that via Modules -&gt; Configure hooks -&gt; choose that particular hook module</t>
           </list>
        </t>
        <t>If you want to enable or disable hooks via code, see also below.</t>
        <t>Note : some modules handle more than one type of items (e.g. articles has different publication types), and you may want to enable hooks for one particular item type in that module. You can do this in the Modules administration as well.</t>
    </section>

    <section title="Designing your module to make use of hooks">
        <t>Insert xarModCallHooks() in all the right places - cfr. example module.  // TODO: improve the parameters</t>
        <t>The syntax of the xarModCallHooks() function is as follows :
           <artwork>
$outputarray = xarModCallHooks('&lt;hookobject&gt;', '&lt;hookaction&gt;', $objectid, $extrainfo);
           </artwork></t>
        <t>In general, API hooks expect an associative array containing the current item information as $extrainfo,
           and return that array with extended or transformed information.
           GUI hooks expect the same item information as $extrainfo, and return an associative array of hookmodule => hookoutput pairs        </t>
        <t>By default, hooks are always called for the current "main module". If you need to call the hooks for another module, e.g. in a block or API function,
           you can specify the caller module in $extrainfo['module']. If your module deals with different item types, you should pass on the
           currently relevant item type via $extrainfo['itemtype'].</t>

            <section title="Calling Item Transform Hooks (API)">
                    <artwork>
Module code in xaruser.php :

function &lt;module&gt;_user_display($args)
{
    ...
    // get the item information
    $item = xarModAPIFunc('&lt;module&gt;', 'user', 'get',
                          array('someid' => $itemid, ...));
    ...
    // add some arguments for hooks
    $item['module'] = '&lt;module&gt;';
    $item['itemtype'] = $itemtype;
    ...
/* old-style transform hooks
    list($item['some'],
         $item['pieces'],
         $item['of'],
         $item['text']) = xarModCallHooks('item', 'transform', $itemid,
                                          // the pieces of text you want to transform here
                                          array($item['some'],
                                                $item['pieces'],
                                                $item['of'],
                                                $item['text']));
*/
    // the fields (array keys) corresponding to the pieces of text you want to transform here
    $item['transform'] = array('some', 'pieces', 'of', 'text');

    // transform item
    $item = xarModCallHooks('item', 'transform', $itemid, $item);
    ...
}
                    </artwork>
            </section>

            <section title="Calling Item Display Hooks (GUI)">
                    <artwork>
Module code in xaruser.php :

function &lt;module&gt;_user_display($args)
{
    ...
    // get the item information
    $item = xarModAPIFunc('&lt;module&gt;', 'user', 'get',
                          array('someid' => $itemid, ...));
    ...
    // add some arguments for hooks
    $item['module'] = '&lt;module&gt;';
    $item['itemtype'] = $itemtype;
    ...
/* old-style display hooks
    $hookoutput = xarModCallHooks('item', 'display', $itemid,
                                  // the URL to return to e.g. after rating the item, or commenting on it, or ...
                                  xarModURL('&lt;module&gt;', 'user', 'display',
                                            array('someid' =&gt; $itemid, ...))
                                 );
*/
    // the URL to return to e.g. after rating the item, or commenting on it, or ...
    $item['returnurl'] = xarModURL('&lt;module&gt;', 'user', 'display',
                                   array('someid' =&gt; $itemid, ...));
    // get display hook output
    $hookoutput = xarModCallHooks('item', 'display', $itemid, $item);

    if (empty($hookoutput)) {
       $data['hooks'] = '';
    } elseif (is_array($hookoutput)) {
        // $hookoutput['comments'] contains the hook output for comments,
        // $hookoutput['hitcount'] contains the hook output for the hitcount,
        // $hookoutput['ratings'] contains the hook output for ratings, and so on...

        // you can use them individually in the template, or join everything together
        $data['hooks'] = join('',$hookoutput);
    } else {
        // this will no longer be relevant
        $data['hooks'] = $hookoutput;
    }
    ...
}
                    </artwork>
            </section>

            <section title="Calling Item Create/Update/Delete Hooks (API)">
                    <artwork>
Module code in xaradminapi.php :

function &lt;module&gt;_adminapi_create($args)
{
    ...
    // create the item first
    ...
    // then add some arguments for hooks, including the newly created itemid
    $args['module'] = '&lt;module&gt;';
    // adapt if you're dealing with several types of items in your module
    $args['itemtype'] = 0;
    $args['itemid'] = $itemid;
    // then call the create hooks
    $result = xarModCallHooks('item', 'create', $itemid, $args);
    ...
}

function &lt;module&gt;_adminapi_update($args)
{
    ...
    // update the item first
    ...
    // then add some arguments for hooks
    $args['module'] = '&lt;module&gt;';
    // adapt if you're dealing with several types of items in your module
    $args['itemtype'] = 0;
    $args['itemid'] = $itemid;
    // then call the update hooks
    $result = xarModCallHooks('item', 'update', $itemid, $args);
    ...
}

function &lt;module&gt;_adminapi_delete($args)
{
    ...
    // add some arguments for hooks
    $args['module'] = '&lt;module&gt;';
    // adapt if you're dealing with several types of items in your module
    $args['itemtype'] = 0;
    $args['itemid'] = $itemid;
    // then call the delete hooks
    $result = xarModCallHooks('item', 'delete', $itemid, $args);
    ...
    // then delete the item itself at last
    ...
}
                    </artwork>
                    <t>Note:  in some cases, you may want to call update hooks even when you're only
                       updating part of a module item (e.g. the status of several articles, or the password
                       of a user). In that case, you should signal the hook modules that they should
                       not update any hooked values because they won't be available :</t>
                    <artwork>
xarVarSetCached('Hooks.all','noupdate',1);
                    </artwork>
            </section>

            <section title="Calling Item New/Modify Hooks (GUI)">
                    <artwork>
Module code in xaradmin.php :

function &lt;module&gt;_admin_new($args)
{
    ...
    // we have no item information here yet
    $item = array();
    // we don't have an item id yet either
    $itemid = '';
    ...
    $item['module'] = '&lt;module&gt;';
    // adapt if you're dealing with several types of items in your module
    $item['itemtype'] = 0;
    $item['itemid'] = $itemid;

    $hookoutput = xarModCallHooks('item', 'new', $itemid, $item);
    if (empty($hookoutput)) {
        $data['hooks'] = '';
    } elseif (is_array($hookoutput)) {
        // $hookoutput['categories'] contains the hook output for categories,
        // $hookoutput['dynamicdata'] contains the hook output for dynamicdata, and so on...

        // you can use them individually in the template, or join everything together
        $data['hooks'] = join('',$hookoutput);
    } else {
        // this will no longer be relevant
        $data['hooks'] = $hookoutput;
    }
    ...
}

function &lt;module&gt;_admin_modify($args)
{
    ...
    // get the item information
    $item = xarModAPIFunc('&lt;module&gt;', 'user', 'get',
                          array('someid' => $itemid, ...));
    ...
    $item['module'] = '&lt;module&gt;';
    // adapt if you're dealing with several types of items in your module
    $item['itemtype'] = 0;
    $item['itemid'] = $itemid;

    $hookoutput = xarModCallHooks('item', 'modify', $itemid, $item);
    if (empty($hookoutput)) {
        $data['hooks'] = '';
    } elseif (is_array($hookoutput)) {
        // $hookoutput['categories'] contains the hook output for categories,
        // $hookoutput['dynamicdata'] contains the hook output for dynamicdata, and so on...

        // you can use them individually in the template, or join everything together
        $data['hooks'] = join('',$hookoutput);
    } else {
        // this will no longer be relevant
        $data['hooks'] = $hookoutput;
    }
    ...
}
                    </artwork>
            </section>

            <section title="Calling Module Configuration Hooks (GUI/API)">
                    <artwork>
Module code in xaradmin.php :

function &lt;module&gt;_admin_modifyconfig($args)
{
    ...
    $extrainfo = array();
    $extrainfo['module'] = '&lt;module&gt;';
    // adapt if you're dealing with several types of items in your module
    $extrainfo['itemtype'] = 0;

    $hookoutput = xarModCallHooks('module', 'modifyconfig', '&lt;module&gt;', $extrainfo);
    if (empty($hookoutput)) {
        $data['hooks'] = '';
    } elseif (is_array($hookoutput)) {
        // $hookoutput['categories'] contains the hook output for categories,
        // $hookoutput['dynamicdata'] contains the hook output for dynamicdata, and so on...

        // you can use them individually in the template, or join everything together
        $data['hooks'] = join('',$hookoutput);
    } else {
        // this will no longer be relevant
        $data['hooks'] = $hookoutput;
    }
    ...
}

function &lt;module&gt;_admin_updateconfig($args)
{
    ...
    $extrainfo = array();
    $extrainfo['module'] = '&lt;module&gt;';
    // adapt if you're dealing with several types of items in your module
    $extrainfo['itemtype'] = 0;

    $result = xarModCallHooks('module', 'updateconfig', '&lt;module&gt;', $extrainfo);
    ...
}
                    </artwork>
            </section>
            <section title="Providing Special-Purpose Hooks : Search, UserMenu, WaitingContent, ...">
                 <t>In this case, you'll need to create a hook function and register it at initialisation - see next section</t>
            </section>

            <section title="Other hook-related functions">
                <t>You can check if a particular hook module is enabled for your module by using the xarModIsHooked() function :
                    <artwork>
   ...
   if (xarModIsHooked('&lt;hookmodule&gt;')) {
   }
   ...
                    </artwork>
                    If you want to use this in places where your module may not be the current "main module", e.g. in blocks or API functions,
                    you should specify the caller module as an extra parameter :
                    <artwork>
   ...
   if (xarModIsHooked('&lt;hookmodule&gt;', '&lt;yourmodule&gt;')) {
   }
   ...
                    </artwork>
                    And if you want to check if a hook is enabled for a particular item type in your module, you should specify the item type
                    as the third argument :
                    <artwork>
   ...
   if (xarModIsHooked('&lt;hookmodule&gt;', '&lt;yourmodule&gt;', $thistype)) {
   }
   ...
                    </artwork>
                </t>
                <t>You can enable hooks to your module via code, e.g. at initialisation, by using one of the API functions provided by the 'modules' module :
                    <artwork>
   ...
    xarModAPIFunc('modules', 'admin', 'enablehooks',
                  array('callerModName' => '&lt;yourmodule&gt;', 'hookModName' => '&lt;hookmodule&gt;'));
   ...
                    </artwork>
                </t>
                <t>To disable hooks via code, you can use the corresponding function as well :
                    <artwork>
   ...
    xarModAPIFunc('modules', 'admin', 'disablehooks',
                  array('callerModName' => '&lt;yourmodule&gt;', 'hookModName' => '&lt;hookmodule&gt;'));
   ...
                    </artwork>
                   To specify a particular item type in one of those two functions, you can use the extra parameter 'callerItemType' here.
                </t>
            </section>

    </section>

    <section title="Providing hook functions in your module">
        <t>Decide what functionality you want to offer first, then see what type(s) of hooks you need to provide for that...</t>
        <t>Please note that your hook function may be called by modules other than the current "main module", so you should check for any optional $extrainfo['module']
           parameter if your hook module stores information regarding particular modules or module items. Some modules calling your hook functions might also be handling
           several item types, which they will pass as an optional $extrainfo['itemtype'] parameter. So your module should take into account that item type as well, if
           relevant.</t>
            <section title="Writing an API hook function">
                 <artwork>
Module code in xaruserapi.php or xaradminapi.php :

/**
 * The hook function you want to provide, e.g. for 'item' 'transform' 'API'
 *
 * @param $args['objectid'] ID of the object
 * @param $args['extrainfo'] extra information
 * @returns array
 * @return extrainfo the updated extrainfo array
 */
function &lt;module&gt;_&lt;type&gt;api_&lt;hookfunc&gt;($args)
{
    ...
}
                 </artwork>
                    <t>Note:  in some cases, people may want to call update hooks even when they're only
                       updating part of a module item (e.g. the status of several articles, or the password
                       of a user). In that case, your hook module should not update any hooked values
                       because they won't be available :</t>
                    <artwork>
    if (xarVarIsCached('Hooks.all','noupdate')) {
        // return without updating any values
        return $args['extrainfo'];
    }
                    </artwork>
            </section>

            <section title="Writing a GUI hook function">
                 <artwork>
Module code in xaruser.php or xaradmin.php :

/**
 * The hook function you want to provide, e.g. for 'item' 'display' 'GUI'
 *
 * @param $args['objectid'] ID of the object
 * @param $args['extrainfo'] extra information
 * @returns string
 * @return the HTML output for this hook function
 */
function &lt;module&gt;_&lt;type&gt;_&lt;hookfunc&gt;($args)
{
    ...
}
                 </artwork>
            </section>

            <section title="Registering hook functions">
                 <artwork>
Module code in xarinit.php :

function &lt;module&gt;_init()
{
    ...
    xarModRegisterHook(// the type of hook you want to register
                       'item', 'display', 'GUI',
                       // the hook function to be called
                       '&lt;module&gt;', '&lt;type&gt;', '&lt;hookfunc&gt;');
    ...
}

function &lt;module&gt;_delete()
{
    ...
    xarModUnregisterHook(// the type of hook you want to unregister
                         'item', 'display', 'GUI',
                         // the hook function to be called
                         '&lt;module&gt;', '&lt;type&gt;', '&lt;hookfunc&gt;');
    ...
}
                 </artwork>
            </section>

            <section title="Creating a Search hook function (GUI)">
                 <t>A search hook function is only going to be invoked by the search module. Next to the standard $args['objectid'] and $args['extrainfo'] arguments,
                    which are not going to contain anything interesting here, your search hook function will be able to retrieve the current search query via the input variable 'q'.</t>
                     <artwork>
Module code in xaruser.php :

/**
 * The hook function you want to provide for 'item' 'search' 'GUI'
 *
 * @param $args['objectid'] ID of the object
 * @param $args['extrainfo'] extra information
 * @returns string
 * @return the HTML output for this hook function
 */
function &lt;module&gt;_user_search($args)
{
    list($q,
         $author,
         $...) = xarVarCleanFromInput('q',
                                      'author',
                                      '...');
    if (empty($q)) {
        // return part of a search form, with input fields relevant to your module
        ...
    } else {
        // return the results for your module
        ...
    }
}
                     </artwork>
                 <t>You can add other input fields of your own in the GUI output, but make sure they don't create a conflict with input fields from other modules.
                    Note that the same function will be invoked by the search module to show (part of) the search form, but also to show (part of) the result page.</t>
            </section>

            <section title="Creating a User Menu hook function (GUI)">
                 <t>A user menu hook function is only going to be invoked by the roles module, to generate some user menu in the "Your Account" page.
                    You can use this e.g. to allow users to change their preferences for your module from within the "Your Account" page.</t>
                     <artwork>
Module code in xaruser.php :

/**
 * The hook function you want to provide for 'item' 'usermenu' 'GUI'
 *
 * @param $args['objectid'] ID of the object
 * @param $args['extrainfo'] extra information
 * @returns string
 * @return the HTML output for this hook function
 */
function &lt;module&gt;_user_usermenu($args)
{
    list($update,
         $bold,
         $itemsperpage,
         $...) = xarVarCleanFromInput('update',
                                      'bold',
                                      'itemsperpage',
                                      '...');
    if (!empty($update)) {
        // update the user preferences
        if (isset($bold)) {
            xarModSetUserVar('&lt;module&gt;', 'bold', 1);
        } else {
            xarModSetUserVar('&lt;module&gt;', 'bold', 0);
        }
        ...
    } else {
        // get the current user preferences
        $bold = xarModGetUserVar('&lt;module&gt;', 'bold');
        ...
    }
    // show an input form where the user can change his preferences for your module
    // Tip : include a hidden field called 'update' in the form, so that you know
    //       when to update the user preferences, and when to simply show them
    ...
}
                     </artwork>
                 <t>Note that the same function will be invoked by the roles module to show the current preferences of the user, and also to update them.</t>
            </section>

            <section title="Creating a Module Remove hook function (API)">
                 <t>If your hook module keeps track of some information for module items of different modules, you may want to do some clean-up in your own table(s)
                    when some hooked module gets deleted by the site administrator. In this case, you can define a 'module' 'remove' 'API' function
                    that will be automatically invoked by Xaraya.</t>
                 <artwork>
Module code in xaradminapi.php :

/**
 * The hook function you want to provide for 'module' 'remove' 'API'
 *
 * @param $args['objectid'] ID of the object
 * @param $args['extrainfo'] extra information
 * @returns array
 * @return extrainfo the updated extrainfo array
 */
function &lt;module&gt;_adminapi_removehook($args)
{
    extract($args);
    ...
    // in this case, $objectid will contain the name of the module that is being removed
    $modid = xarModGetIDFromName($objectid);
    // do some clean-up in your table(s) for that module
    ...
}
                 </artwork>
            </section>
    </section>

    <section title="Hints on using different item types in your modules">
<t>
Many of the more complex modules deal with different types of items.
For instance : articles, calendar, cast, contact, events, issueareapub,
nascar, shopping, todolist, workflow, xarbb or xproject.
</t>
<t>
Unfortunately, they often don't make use of the notion of item types,
which means that they (and your future module users) can't really benefit
from Xaraya's hook system. Wouldn't it be nice if you could enable
categories just for one item type, or extend your item types in distinct
ways via dynamicdata, or enable transformations for some item types
but not for others, etc. ? :-)
</t>
<t>
Here's a little overview on how to adapt your modules to use item types,
so that you can make full use of the Xaraya hook system.
</t>
<section title="Identify your item types">
<t>
This is generally pretty easy - just see how many different module tables
that you have in your module. Each of those is probably a good candidate
for becoming a separate item type.
</t>
<t>
Or if you have lots of similar functions like create_this, create_that, etc., 
that's another indicator for spotting item types.
</t>
</section>
<section title="Make them known to Xaraya">
<t>
All you need for that is to provide a user API function getitemtypes(), in
modules/&lt;mymodule>/xaruserapi/getitemtypes.php or in your global
modules/&lt;mymodule>/xaruserapi.php file.
</t>
<t>
This way, the hook system will know your module handles different
item types, and it will present them as separate checkboxes to the
site admin in the hooks configuration screens.
</t>
<t>
Your getitemtypes() function should return an array of
                 <artwork>
$itemtypes[$itemtype] = array('label' => 'some label to display',
                              'title' => 'some link title to use',
                              'url' => &lt;url to view them (if relevant)>);
                 </artwork>
</t>
<t>
In some cases, this array will be static (e.g. one per module table),
or in others this may be built up dynamically - like for articles pubtypes
or dynamicdata objects for instance.
</t>
</section>
<section title="Call the right hooks with the right arguments">
<t>
Many modules still don't specify the calling module or item type
in their hook calls, or don't even call hooks at all. This makes it
impossible for Xaraya to figure out which hooks it should actually call,
so you'll want to go through your code and adapt the xarModCallHooks()
calls if necessary.
</t>
<t>
This RFC explains the
different hook calls and what parameters they expect. In most cases,
adaptation is pretty straight-forward : just create an array with the
item information, the module and the itemtype, and pass that as $extrainfo
argument instead of (whatever).
</t>
</section>
<section title="Sit back and relax :-)">
</section>
<t>
========================== extra credit ==========================
</t>
<t>
There are a few other things you can do to make life easier for your
module users later on :
</t>
<section title="Provide links to your items in top hits, top ratings, categories etc.">
<t>
For this, you'll need to have a user API function getitemlinks(), that
accepts the itemtype and an array of itemids as input, and returns an
array of
                 <artwork>
$itemlinks[$itemid] =  array('label' => 'some text/title to display',
                             'title' => 'some link title to use',
                             'url' => &lt;url to display it (if relevant)>);
                 </artwork>
</t>
</section>
<section title="Working with categories">
<t>
Now that the categories module supports different item types per module,
you can re-use it more easily to let your users navigate through your
items by category.
</t>
<t>
The easiest approach would be to define a dynamic object for each of your
item types, and to let DD handle the selection for you. For that, all you
need to do is fetch the 'catid' variable from the input, and pass it along
to your DD function call or BL tag, together with the item type that you're
dealing with. You'll find some different ways to do that in the dyn_example
module.
</t>
<t>
Slightly more difficult is when you're doing your own database queries etc.
In that case, you can retrieve the relevant pieces of SQL from the categories
module, and include them in your queries. For instance :

                 <artwork>
if (xarModIsHooked('categories','mymodule',$thistype)) {
    // Get the LEFT JOIN ... ON ...  and WHERE parts from categories
    $categoriesdef = xarModAPIFunc('categories','user','leftjoin',
                                   array('modid' => 
                                          xarModGetIDFromName('mymodule'),
                                         'itemtype' => $type,
                                         'catid' => $catid));
    $query = "SELECT xar_this, xar_that
              FROM ( $mytable
              LEFT JOIN $categoriesdef[table]
              ON $categoriesdef[field] = xar_myitemid )
              $categoriesdef[more]
              WHERE xar_whatever = 'something'
              AND $categoriesdef[where]";
} else {
    $query = "SELECT xar_this, xar_that
              FROM $mytable
              WHERE xar_whatever = 'something'";
}
                 </artwork>
</t>
<t>
And retrieving the categories for some items can be done with :

                 <artwork>
$cids = xarModAPIFunc('categories','user','getlinks',
                      array('iids' => array($item1, $item2, ...),
                            'itemtype' => $mytype,
                            'modid' => xarModGetIDFromName('mymodule'),
                            'reverse' => 1));
                 </artwork>
</t>
<t>
Now all you need to do is add some categories navigation tag in your
templates, and people will be able to browse through your items too :

                 <artwork>
&lt;xar:if condition="xarModIsHooked('categories','mymodule',$thistype)">
  &lt;xar:categories-navigation layout="trails" showchildren="1" 
  module="mymodule" itemtype="$thistype" catid="$catid" />
&lt;/xar:if>
                 </artwork>
</t>
<t>
Note: all of that is done automagically by the dynamicdata module
if you let it handle the selection and display :-)
</t>
</section>
<t>
That's about all I can think of regarding item types, and how
you can benefit from Xaraya's hook system by using them...
</t>
    </section>
<section title="Notes on the roles module">
    <t>The roles module uses hooks among other things in the delete, purge and recall API calls.</t>
    <t>
    <spanx>Delete:</spanx> A deleted role is still present but not visible, and can be recalled to become visible again. The roles module ignores deleted roles in all of its operations.
    </t>
    <t>
    <spanx>Recall:</spanx> A recalled role is one that was previously deleted (and therefore ignored), but is put back into circulation again..
    </t>
    <t>
    <spanx>Purge:</spanx> A purged role is for all practical purposes completely gone from Xaraya. References to it are maintained for data integrity purposes, but it cannot be accessed or recalled.
    </t>
    <t>
    The API calls that perform delete, recall and purge in the roles module each have a hook call that lets other modules know that the action has taken place.
    Since other modules or external applications may or may not have equivalent concepts, the hook calls are variants of conventional "delete" and "create" hook calls. Each call has an additional bit of information that specifies it. For example the hook call in the recall API function is:
    </t>
    <artwork>
// Let any hooks know that we have recalled this user.
$item['module'] = 'roles';
$item['itemid'] = $item['uid'];
$item['method'] = 'recall';
xarModCallHooks('item', 'create', $uid, $item);
    </artwork>
    <t>
    It is up to modules to analyze these calls and take appropriate action based on their own state.
    </t>
</section>

    <section title="When (not) to use hooks">
        <t>Comparison with API calls and the event system...</t>
    </section>

    <section title="Implementation Details">
        <t>Current stuff in the core and modules module...</t>
    </section>

    <section title="Future Evolution">
        <t>One major drawback of the current hook types is that most of the hooked functionality can only be used when you're
           dealing with individual module items, not when you're dealing with several items at once. So you can't easily select
           module items based on some hooked information, or show some hooked information when viewing a list of items.</t>
        <t>In order to provide the same kind of functionality when dealing with more than one module item, we can't simply
           add some GUI output in a list - we need some way to integrate the data retrieval from those "loosely coupled" hook
           modules with the data retrieval for the module items themselves, or work on the API and/or BL level to achieve the same thing.</t>
        <t>A first approach to address this issue -used by the articles module at the moment (March 2003)- consisted of making the module
           "aware" of several commonly used hooks, and to include the data retrieval and GUI integration for those hooks in the module code.
           This solves the immediate problem of integrating certain hooks when dealing with lists of articles, and still allows you to enable
           or disable those hooks via administration, but it goes against the idea of "loose coupling" and requires extensive code in the module itself.</t>
        <t>A more generic approach -for use by any module- is being investigated on the data access level. Whether this will be limited to
           some kind of "SQL hooks", or will cover the whole issue of data access to module items together with their "related" information
           is still being explored at the moment. Either way, some changes are to be expected in the hook calls in the future.</t>
    </section>

    <!-- Revision history is mandatory -->
    <section title="Revision history">
      <t>2003-10-24: Add Hints on using different item types in your modules</t>
      <t>2003-06-28: Add comments on how to call hooks on behalf of a particular module, and how to specify the item type (if any)</t>
      <t>2003-03-27: Start filling in some sections</t>
      <t>2003-02-27: Created</t>
    </section>
    
  </middle>
  
  <!-- Back matter is used for references and appendices which come after the references -->
  <back>
   
    <!-- Any section after this will become an appendix -->

  </back>
</rfc>
