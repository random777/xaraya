<?xml version="1.0" encoding="iso-8859-1"?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xsl"?>
    <!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<!-- <?rfc private='my private memo'?>  Produce a private memo rather than a Xaraya-standard --> 
<?rfc toc="yes"?>

<rfc number="0035" category="std">
  <!-- number: Fill in the number for the RFC -->
  <!-- obsoletes: Comma separated list of RFC numbers which this one obsoletes -->
  <!-- category: std=standard, bcp=best common practice, info=info, exp=experimental, historic=historic -->

  <!-- Front matter is used for identification of author and organization -->
  <front>
    <title>Query Abstraction</title>
    <author initials="F.B." surname="Botelho" fullname="Flavio Borges Botelho">
      <organization>Xaraya Development Group</organization>
      <address>
        <email>nuncanada@xaraya.com</email>
        <uri>http://www.xaraya.com</uri>
      </address>
    </author>
    <date month="January" year="2003"/>
    
    <!-- Initiating team for this RFC -->
    <workgroup>Project Management Committee</workgroup>

    <!-- List keywords for the RFC here -->
    <keyword>SQL</keyword>
    <keyword>database</keyword>
    <keyword>query</keyword>
    <keyword>abstraction</keyword>

    <!-- The abstract summarizes in one or two paragraphs the content of the RFC -->
    <abstract>
      <t>
        This RFC presents a proposal for Query Abstraction inside Xaraya Architeture.
      </t>
    </abstract>
  </front>

  <!-- The middle section is used for the actual content of the RFC -->
  <middle>
    <!-- Introduction is mandatory -->
    <section title="Introduction">
      <t>
        Query Abastraction has been made necessary to give us the hability to generate
        efficient SQL queries which are portable across all our Database Pool. It will
        provide us a way to create queries without any preocupations about the
        underlying storage system.
      </t>
    </section>

    <section title="Pros">
      <t>
         "Allows for the creation of queries in a persistent storage neutral manner.
         Expressed as objects, queries remain consistent across multiple persistent
         storage solutions. Should the database change from RDB to an OODB " or even to
         XML Based Query Languages (A lot of research is being done in the field - References [3,4]),
         "no part of the application will need to be modified." - Reference [2]
      </t>
    </section>

    <section title="Requirements List">
      <t>
         The following is list of requirements about the implementation of the Query Abstraction.
         Please add your own.
      </t>
      <t>
      <list style="numbers">
        <t>Turn Xaraya completely database agnostic. [Main reason to be implementing this]</t>
        <t>As we already have a DB Abstraction Library (ADODB), this should be an extension of it. [Gary]</t>
        <t>Devs should be able to keep using their known SQL for simple queries, where portability is not
           a problem. [LadyofDragons]</t>
        <t>The query structure should be able to be passed around the program and receive input from
           many different modules. [Nuncanada]</t>
      </list>
        </t>
    </section>

    <section title="Sugestions List">
      <t>
         The following is list of sugestions made for the RFC.
         Please add your own.
      </t>
      <t>
      <list style="numbers">
        <t>Make the methods name closer to their meaning in english than as the names being close to their sql equivalent [???]</t>
        <t>Make a interface thru a meta-language, that will be easier to read and understand than the nested methods [Jason Judge]</t>
        <t>Abstract INSERT/UPDATE queries too [Marcinmilan]</t>
      </list>
        </t>
    </section>

    <section title="Possible Implementations Reasearch">
      <t>
         There just a few query abstraction packages for PHP, 2 found in the PEAR archives. Both
         have serious shortcomings to our needs (DB_DataObjects and DB_QueryTool).
         Both were made without taking in account the necessity to handle multiple DBs.
      </t>
      <t>
         Research done in other languages for inspiration has shown that most query abstractor out there
         have too simplistic approaches, mainly:
         <list style="numbers">
           <t>Simplistic - They simply support the most basic features of the SELECT query, where the own SQL
              language is already the basic abstraction.</t>
           <t>Placeholders - They simply store 'common' queries with wildcards showing where the input values
              should be added. Clearly this doesnt produce DB independent SQL. </t>
           <t>Stored queries - They store the DB-specific query in files to be called, would be a similar system
              to that of using our MLS system to translate SQL queries to a specific DB dialect.
              This requires you to know how to implement the query in every DB, and although it is able to
              support more complex queries than the simplitic approach. It is not able to translate
              dynamic queries.</t>
          </list>
          
          So there are two possible implementaions:
         <list style="numbers">
           <t>Stored queries - It's not able to translate dynamic queries. And it will probably create
              bigger problems than translations themselves (as i think it is easier to find a translator than
              a DB specialist). Requiring that the Mod Dev himself creates the translation to all possible DBs
              doesnt seem like a good idea.</t>
           <t>OO Query Abstraction - The good part is that it can implement all our requirements and could
              be a link towards future storage systems. Still it will obligate Mod Devs to learn it (for
              more complex queries) instead of using the well known SQL.</t>
          </list>
      </t>
    </section>

    <section title="Implementation Idea">
      <t>The following is where the proposed implementation itself is shown</t>
      <t>
         There should be two separate concepts, that of the query structure which preferebly would
         be a class used only to hold the devs wishes, and drivers to take this annotated wish list
         and transform it into a proper query.
      </t>
      <t> The basic idea is a simple one, you will have a class (our query abstraction class) which
          will *hold* (with pointers, creating a rigid structure of relations) what the developer
          is trying to achieve.
          Then when he thinks he already has everything he wants in the 'shopping list', this
          structured list will be passed over to a specific DB driver which will translate the given
          structure in the best possible query for the developer.
       </t>
    </section>


    <section title="Concept of how the query abstraction would be used">
      <t> How would it work:
        <artwork>
    This would work if there was data present in the xartables.php informing us what are the tables,
    their fields, their foreign keys with the nature of the relationship (1-1, 1-Many, Many-Many,
    what to do with missing values on one side and/or the other?)

    $query =&#38; new sql_select;
    $query-&#62;select('name','description','left','right');
    $result =&#38; $query-&#62;run();

    Assuming there is a 1-1 relationship between users and their groups, in two separated tables
    and that this is properly set in the xartables.php
    $query =&#38; new sql_select;
    $query-&#62;select('username','groupname');
    $result =&#38; $query-&#62;run();

    {Now on omitting $query =&#38; new sql_select; }

    You would be able to do any query including joins that easily unless there were conflicting field names
    then you would have to set their respective tables:

    Suppose there is an alias field in the user table and a alias in the groups table
    This way the bulder wont know which alias to choose

    $query-&#62;select('username','groupname','alias');


    Right now i am thinking about this:

    $field =&#38; $query-&#62;create('field','alias');
    $field-&#62;table('groups');
    $query-&#62;select('username','groupname', $field);

    But can be changed to other syntaxes:  (After writing, i think this one seems better)

    $field =&#38; $query-&#62;field('alias', 'groups');
    $query-&#62;select('username','groupname', $field);

    Or:
    $field =&#38; $query-&#62;field('alias');
    $field-&#62;table('groups');
    $query-&#62;select('username','groupname', $field);

    Which one is the best? Please comment!!!!

    Now the part where i havent found a better way of doing the syntax:
    It is simple, but a lot of nested code...

    $query-&#62;where($query-&#62;condition('userid','&#62;','1000'));

    So, something like this:
    "SELECT
            COUNT(P2.".$categoriescolumn['cid'].") AS indent,
            P1.".$categoriescolumn['cid'].",
            P1.".$categoriescolumn['name'].",
            P1.".$categoriescolumn['description'].",
            P1.".$categoriescolumn['image'].",
            P1.".$categoriescolumn['parent'].",
            P1.".$categoriescolumn['left'].",
            P1.".$categoriescolumn['right']."
       FROM $categoriestable AS P1,
            $categoriestable AS P2
      WHERE P1.".$categoriescolumn['left']."
            &#62;= P2.".$categoriescolumn['left']."
        AND P1.".$categoriescolumn['left']."
            &#60;= P2.".$categoriescolumn['right'];"

    Would be something like:

    $P1 = $query-&#62;table('categories','P1');
    $P2 = $query-&#62;table('categories','P2');
    $query-&#62;select(
        $query-&#62;function('COUNT',$query-&#62;field('cid',$P2),'indent'),
        $query-&#62;field('cid',$P1),
        $query-&#62;field('name',$P1),
        $query-&#62;field('description',$P1),
        $query-&#62;field('image',$P1),
        $query-&#62;field('parent',$P1),
        $query-&#62;field('left',$P1),
        $query-&#62;field('right',$P1));

    $query-&#62;where(
        $query-&#62;condition(
            $query-&#62;condition($query-&#62;field('left',$P1),'&#62;=',$query-&#62;field('left',$P2)),
            'AND',
            $query-&#62;condition($query-&#62;field('right',$P1),'&#60;=',$query-&#62;field('right',$P2))));


    Comment!

        </artwork>
      </t>
    </section>

    <section title="Concept sketch of the proposed code">
      <t> Sketch of the proposed code:
        <artwork>
/* 5 basic SQL structure types: alias, table, field, function, condition
 * Special structures: CASE, USER_VARIABLE???
 */


// 3 very simple equal (if werent for the hierarchy) classes...
// Leaving like this for now, as it helps understand what is the idea.
// get_class($object) == 'sql_alias'


class sql_alias {
    var $alias;
    //Constructor
    function sql_alias ($alias) {$this-&#62;alias = $alias;}
    function get_alias () {return $this-&#62;alias;}
}

class sql_table extends sql_alias {
    var $table;
    //Constructor
    function sql_table ($table, $alias = NULL) {
        $this-&#62;table = $table;
        if ($alias !== null) {
            $this-&#62;sql_alias($alias);
        }
    }
}

class sql_field extends sql_table {
    var $field;
    //Constructor
    function sql_field ($field, $table = NULL, $alias = NULL) {
        $this-&#62;field = $field;
        if ($table !== null) {
            $this-&#62;sql_table($table);
        }
        if ($alias !== null) {
            $this-&#62;sql_alias($alias);
        }
    }
    function get_field () {return $this-&#62;field;}
}

class sql_function extends sql_alias{
    //Functions: SUM, AVG, COUNT, MIN, MAX, LIKE, NOT, any other??
    var $function;
    //Points to a sql structure (field, function or condition)
    var $pointer;
    function sql_function ($function, $pointer, $alias = NULL) {
        $this-&#62;function = $function;
        $this-&#62;pointer = $pointer;
        if ($alias !== null) {
            $this-&#62;sql_alias($alias);
        }

    }
    function get_function () {
        return Array('function' =&#62; $this-&#62;function, 'pointer' =&#62; $this-&#62;pointer);
    }
}

class sql_condition
{
    //Points to a sql structure (field, function or another condition))
    var $pointer1, $pointer2;
    //Connectives: +, -, /, *, =, &#62;, &#60;, &#60;=, &#62;=, any other??
    var $connective;
    function sql_condition ($pointer1, $connective, $pointer2) {
        $this-&#62;pointer1 = $pointer1;
        $this-&#62;pointer2 = $pointer2;
        $this-&#62;connective = $connective;
    }
    function get_condition () {
        return Array('pointer1' =&#62; $this-&#62;pointer1, 'pointer2' =&#62; $this-&#62;pointer2, 'connective'=&#62;$this-&#62;connective);
    }
}

    // Should CASE (or DECODE or iff) be considered a function? No! It is a special case
    // I think it maybe the case for having a special function (as i think ADODB will have
    // such a function sooner or later)
    //Use Example : SELECT a.ManagerName, SUM(CASE WHEN b.Approval='Y' THEN 1 ELSE 0 END) as Y,
class sql_case
{
    var $case = Array ();
    function add_case ($when, $then, $else) {
        $case[] = Array ('when' =&#62; $when, 'then' =&#62; $then, 'else' =&#62; $else);
    }
}


// sql_connective or sql_operator?
// class sql_connective {}
//  Dont think it is necessary... They are considered strings...

/**
 * Helper Class to mount a SQL Select Query
 * Its a little more than a struct, keeping the different 'areas' from
 * the Select Query separated. So tables, fields and join statements can be
 * easily exchanged between different parts of the code.
 */
class SQL_SELECT
{
    var $areas = Array ('select'  =&#62; Array(),
                        'from'    =&#62; Array(),
                        'join'    =&#62; Array(),
                        'where'   =&#62; NULL,
                        'groupby' =&#62; Array(),
                        'having'  =&#62; NULL,
                        'orderby' =&#62; Array(),
                        'limit'   =&#62; Array('nrows'=&#62;null,'offset'=&#62;null),
                        'options' =&#62; Array());

    function checkNotTable (&#38;$input) {
        // check('field') needs to be the first, as fields are the standard input
        if (!$this-&#62;check('field',$input)     &#38;&#38;
            !$this-&#62;check('function',$input)  &#38;&#38;
            !$this-&#62;check('condition',$input) &#38;&#38;
            !$this-&#62;check('case',$input)) {
            return false; //Error
        }
        return true;
    }

    function &#38;condition ($pointer1, $connective, $pointer2) {
        if ($this-&#62;checkNotTable($pointer1)) {
            die ('Pointer1 is not a field, function or condition');
            return; //Error
        }

        if ($this-&#62;checkNotTable($pointer2)) {
            die ('Pointer2 is not a field, function or condition');
            return; //Error
        }

        $obj =&#38; new sql_condition ($pointer1, $connective, $pointer2);

        return $obj;
    }

    function &#38;function ($function, $pointer) {
        if ($this-&#62;checkNotTable($pointer)) {
            die ('Pointer is not a field, function or condition');
            return; //Error
        }

        $obj =&#38; new sql_function ($function, $pointer);

        return $obj;

    }

    function &#38;case ()
        if ((func_num_args()%3)!=0) {die('Case can only be assigned in triples : WHEN THEN ELSE');}
        $args = func_get_args();

        $obj =&#38; new sql_case ();

        for ($i=0;$i+=3;$i&#60;func_num_args()) {
            $obj-&#62;add_case($args[$i], $args[$i+1], $args[$i+2]);
        }

        return $obj;
    }

    /**
    * Adds to the SELECT structure
    *
    * @param string Where in the structure you want to add it? (select, from, join, where, groupby, having, orderby)
    *               SELECT ... FROM ... JOIN ... WHERE ... GROUPBY ... HABING ... ORDERBY
    *               This was made this way to make it easier to understand how to use it
    * @params mixed The rest of the parameters depend on the chosen place of structure youre adding to:
    *               SELECT  -&#62; any number of fields
    *               FROM    -&#62; any number of tables
    *               JOIN    -&#62; $table, $on, $jointype
    *               WHERE   -&#62; 1 condition
    *               GROUPBY -&#62; any number of fields
    *               HAVING  -&#62; 1 condition
    *               ORDERBY -&#62; any number of fields
    *
    * @author Nuncanada
    * @access public
    */
/*
 *
 * Can be done both ways :
    As $query-&#62;add('select'....)
    Or $query-&#62;select(...);
    The 2nd seems more natural for us SQL zombies
    function add () {
        $args = func_get_args();
        if (func_num_args()&#62;0) {

            $case = strtolower(array_shift($args));

            switch($case) {
                case 'select':
                    foreach ($args as $arg) {
                        if ($this-&#62;checkNotTable($arg)) {
                            return; //Error
                        }
                    }

                    $this-&#62;areas[$case] = array_merge($this-&#62;areas[$case], $args);
                    break;


                case 'groupby':
                case 'orderby':
                    foreach ($args as $arg) {
                        if (!$this-&#62;check('field',$arg)) {
                            return; //Error
                        }
                    }

                    $this-&#62;areas[$case] = array_merge($this-&#62;areas[$case], $args);
                    break;

                case 'from':
                    foreach ($args as $arg) {
                        if ($this-&#62;check ('table',$arg)) {return;};
                    }

                    $this-&#62;areas[$case] = array_merge($this-&#62;areas[$case], $args);
                    break;

                case 'join':
                    if (count($args)!= 3) {die('Wrong parameter count. Where and Having can only have 1 condition parameter');}
                    if (!$this-&#62;check ('table', $args[0])) {return;}
                    if (!$this-&#62;check ('condition', $args[1]) {return;}

                    $this-&#62;areas['join'][] = Array('table' =&#62; $args[0],
                                                   'condition' =&#62; $args[1],
                                                   'joinType' =&#62; $args[2]);

                    break;

                case 'where':
                case 'having':
                    if (count($args)!=1) {die('Wrong parameter count. Where and Having can only have 1 condition parameter');}
                    if (!$this-&#62;check('condition', $args[0]) {return;} //Error

                    $this-&#62;areas[$case] = $args[0];
                    break;

                default:
                    die('Unknown Area in the query'); //Error
                    break;
            }
        } else {
            die('Nothing to add');
        }
    }
  */
    var $select = Array();
    function select () {
        $args = func_get_args();
        foreach ($args as $arg) {
            if ($this-&#62;checkNotTable($arg)) {
                return; //Error
            }
        }
        $this-&#62;select = array_merge($this-&#62;select, $args);
    }

    var $groupby;
    function groupby () {
        $args = func_get_args();
        foreach ($args as $arg) {
            if (!$this-&#62;check('field',$arg)) {
                return; //Error
            }
        }
        $this-&#62;groupby = array_merge($this-&#62;groupby, $args);
    }

    var $orderby = Array();
    function orderby () {
        $args = func_get_args();
        foreach ($args as $arg) {
            if (!$this-&#62;check('field',$arg)) {
                return; //Error
            }
        }
        $this-&#62;orderby = array_merge($this-&#62;orderby, $args);
    }

    var $from = Array();
    function from () {
        $args = func_get_args();
        foreach ($args as $arg) {
            if (!$this-&#62;check('table',$arg)) {
                return; //Error
            }
        }
        $this-&#62;from = array_merge($this-&#62;from, $args);
    }

    var $join = Array();
    function join ($table, $condition, $joinType = '') {
        if (!$this-&#62;check ('table', $table)) {return;}
        if (!$this-&#62;check ('condition', $condition) {return;}
        $this-&#62;join[] = Array('table' =&#62; $table, 'condition' =&#62; $condition, 'joinType' =&#62; $joinType);
    }

    var $where = NULL;
    function where ($condition) {
        if ($this-&#62;where != NULL) {
            die('Where condition already set');
        }
        if (!$this-&#62;check('condition', $condition) {return;} //Error
        $this-&#62;where = $condition
    }

    var $having = NULL;
    function having ($condition) {
        if ($this-&#62;having != NULL) {
            die('Where condition already set');
        }
        if (!$this-&#62;check('condition', $condition) {return;} //Error
        $this-&#62;having = $condition
    }

    /**
    *   Adds one option to the SELECT syntax. ie DISTINCT
    *
    * @param string Select Option
    * @author Nuncanada
    * @access public
    */
    function addOption($option)
    {
        // Examples: DISTINCT, etc etc
        $this-&#62;areas['options'] = $option;
    }

    /**
    * Sets a Limit to the SELECT
    *
    * @param integer Number of rows
    * @param integer Starting Number
    * @author Nuncanada
    * @access public
    */
    function limit($nrows, $offset)
    {
        $this-&#62;areas['limit'] = array('nrows'=&#62;$nrows,'offset'=&#62;$offset);
    }

    /**
    * Check if an input is of the desired structure
    * If it is a string/int, then turn it into one object that represents the desired structure.
    *
    * @param string SQL structure
    * @param mixed User input - String or object
    * @author Nuncanada
    * @access private
    */
    function check ($structure, &#38;$input) {
        if (!is_object($input)) { //String or int

            //As this is a private function, this is just a reminder for myself while prototyping/testing
            if ($structure == 'condition' || $structure == 'function') {
                die ('Conditional or Functional statements cannot be input as strings.
                      They need their proper encapsulation'); // Error - Call Exceptions
                return;
            } else {
                $input = &#38;$this-&#62;create($structure, $input);
            }
        } elseif (get_class($structure) != 'sql_'.$structure) {
            return false;
        }

        return true;
    }

    /**
    * Creates the desired structure, return it as an object
    *
    * @param string $structure sql structure: 'alias', 'table', 'field', 'function'
    * @return mixed a newly created SQL structure object, or NULL
    * @author Chuck Hagenbuch
    * @access private
    */
    function &#38;create ($structure, $input) {
        $classname = "sql_${structure}";

        if (!class_exists($classname)) {
            return;            //Call Exception
        }

        $obj =&#38; new $classname ($input);

        return $obj;
    }

    /**
    * Get the strings present in a given place in the SQL structure
    * Will be used only by the DB drivers
    *
    * @param string Place in the SQL structure (from, join, where, groupby, having, orderby)
    * @author Nuncanada
    * $access private
    */
    function get ($area)
    {
        return $this-&#62;areas[$area];
    }
}


class SQL_SELECT_MYSQL extends SQL_SELECT
{
    var $intro = Array ('select'  =&#62; 'SELECT ',
                        'from'    =&#62; ' FROM ',
                        'join'    =&#62; ' ',
                        'where'   =&#62; ' WHERE ',
                        'groupby' =&#62; ' GROUP BY ',
                        'having'  =&#62; ' HAVING ',
                        'orderby' =&#62; ' ORDER BY ',
                        'limit'   =&#62; ' LIMIT ');


    function buildQuery ()
    {
        $query = '';
/*  To be done
        foreach ($this-&#62;areas as $area =&#62; $array)
        {
            if (count($array)&#62;0)
            {
                $string = '';

                switch ($area)
                {
                    case 'select':
                    case 'from':
                    case 'groupby':
                    case 'orderby':
                        $string = implode(', ', $array);
                        break;
                    case 'join':
                        $string = implode(' ', $array);
                        break;
                    case 'where':
                    case 'having':
                        $string = implode(' AND ', $array);
                        break;
                    default:
                        $string = 'Unknown Area in the query';
                        break;
                }
                $query .= $this-&#62;intro[$area] . $string;
            }
        }
*/
        return $query;
    }
}

        </artwork>
      </t>
    </section>
    <section title="Example Implementation Idea">
    <section title="Description">
      <t>The following describes an implmentation of a subst of the query abstraction described in this document.
      This implementation does SELECTS, INSERTS, UPDATES and DELETES. Further extensions can bee added.</t>
      <t>
         The exposee is divided into 2 parts: a short description of the API and a number of examples. Further xamples of how this code works can be found in the roles and ledger modules.
      </t>
      <t> 
      By way of a general description the query abstraction consists of a single class xarQuery, of which a given instance can contain and manage a single SQL statement. The class represents a standardized layer between the code and adodb. The different class methods can be used to: 
      <list style="symbols">   
      <t>
      Accept whole SQL statements.or in parts in different imput syntax.
      </t>
      <t>
      Assemble and hold the SQL statement and its parts.
      </t>
      <t>
      Execute the statement.
      </t>
      <t>
      Produce the output.
      </t>
      </list>
      </t>
      <t>
      Some of the benefits of this approach are:
      <list style="symbols">   
      <t>
      Assemble SQL statements dynamically, i.e. when needed.
      </t>
      <t>
      Reuse statements by modifying them.
      </t>
      <t>
      Reduce and standardize the code by incorporating some common features of queries into the class, e.g. number of rows sought for pager output, qstr() etc.
      </t>
      </list>
      </t>
      <t>
      Input of tables and fields to the class can be as strings, lists of strings or arrays. This makes it possible to keep the syntax reasonably simple for simple queries.
      </t>
      <t>
      The xarQuery class can coexist with the adodb syntax. For special cases or simple queries the adodb syntax may be a bit easier.
      </t>
    </section>
    <section title="API">
    <t>
        Example: Recalling a user's data from the database. The data of the user with the uname $this->uname is returned as an array.
    </t>
      <artwork>
        $q = new xarQuery('SELECT',$this->rolestable);
        $q->eq('xar_uname',$this->uname);
        if (!$q->run()) return;
        $foo = $q->output();      
      </artwork>
    <t>
        The syntax of the class call is
    </t>
      <artwork>
        $q = new xarQuery('SELECT'|'INSERT'|'UPDATE'|'DELETE',
                          {array of query tables},
                          {array of fields}
        );
      </artwork>
      <t>
      The class methods (to be completed):
      </t>
      <t>
      Tables and Fields:
      <list style="symbols">   
        <t>
        <em>addfields($fields):</em> add an array of fields to the query.
      </t><t>
        <em>addtables($tables):</em> add an array of tables to thte query.
      </t><t>
        <em>getfield($myfield):</em>  return  a field from the statement.
      </t><t>
        <em>removefield($myfield):</em> remove a field from the statement.
      </t><t>
        <em>join($field1,$field2):</em> join 2 tables via their respective fields..
      </t>
      </list>
      </t>

      <t>
      Conditions:
      <list style="symbols">   
      <t>
        <em>getcondition($mycondition):</em> return  a condition from the statement.
      </t><t>
        <em>removecondition($mycondition):</em> remove a condition from the statement.
      </t><t>
        <em>eq($field1,$field2):</em> add a EQ condition to the query.
      </t><t>
        <em>gt($field1,$field2):</em> add a GT condition to the query.
      </t><t>
        <em>ge($field1,$field2):</em> add a GE condition to the query.
      </t><t>
        <em>le($field1,$field2):</em> add a LE condition to the query.
      </t><t>
        <em>lt($field1,$field2):</em> add a LT condition to the query.
      </t><t>
        <em>like($field1,$field2):</em> add a LIKE condition to the query.
      </t>
      </list>
      </t>

      <t>
      Query output:
      <list style="symbols">   
      <t>
        <em>run($statement='', $flag=1):</em> assemble and execute an SQL statement. If a string with a statement is given it is directly executed. If $flag is 1 then the method output() contains the resultset. If $flag is 0 then the public variable $result contains the adodb resultset. 
      </t><t>
        <em>output():</em> return the query output as a 2 dimensional array where the keys of row elements corespond to the field names in the datatbase.
      </t><t>
        <em>row($row=0):</em> return a single output row as a 1 dimensional array.
        </t>
      </list>
      </t>
      <t>
      Database Connection:
      <list style="symbols">   
      <t>
        <em>open():</em> Open the default db connection.
      </t><t>
        <em>close():</em> Close the default db connection.
      </t><t>
        <em>openconnection($connction):</em> open a db connection.
      </t>
      </list>
      </t>
      <t>
      Miscellaneous:
      <list style="symbols"> 
      <t>
        <em>gettype():</em> return the typ of the query, e.g. SELECT.
      </t><t>
        <em>getstartat():</em> return the record to start the query at.
      </t><t>
        <em>getto():</em> return the records to end the query at.
      </t><t>
        <em>getpagerows():</em> return the number of records to be displayed on a page.
      </t><t>
        <em>getrows():</em> return the total number of reecords the query found
      </t><t>
        <em>addorder($x = '', $y = 'ASC'):</em> add an ordering to the query results
      </t><t>
        <em>setorder($x = '',$y = 'ASC'):</em> set the ordering of the query results
      </t><t>
        <em>setstartat($x = 0):</em> set the record number to begin the query at.
      </t><t>
        <em>setrowstodo($x = 0):</em> set the number of records to b returned.
      </t><t>
        <em>uselimits():</em> turn on the limit filters, i.e. the query will start at a given record and return a certain number of records, depending on the setstartat() and setrowstodo() methods respectively.
      </t><t>
        <em>nolimits():</em> turn off the limit filters, i.e the query will return all the records found.
      </t><t>
        <em>setstatement($x = ''):</em> create a string representation of the SQL query. If $x is empty the query statement is assembled from the data in the query object.
      </t><t>
        <em>getstatement():</em> return a string representation of the SQL query.
      </t>
      </list>
      </t>
    </section>
    <section title="Examples">
    <t>
        The following are equivalent:
    </t>
      <artwork>
        $dbconn = xarDBGetConn();
        $query = "SELECT * FROM $this->rolestable WHERE xar_name = '$this->name'";
        if(!$dbconn->Execute($query)) return;
        
        AND
        
        $q = new xarQuery('SELECT',$this->rolestable);
        $q->eq('xar_name',$this->name);
        if (!$q->run()) return;
        
        AND
        
        $q = new xarQuery();
        if (!$q->run("SELECT * FROM $this->rolestable WHERE xar_name = '$this->name'")) return;        
        </artwork>    
    <t>
        The following are equivalent:
    </t>
      <artwork>
        if (!$q->run($query)) return;
        $invoices = array();
        foreach ($q->output() as $out)
            $invoices[] = array_pop($out);
        return $invoices;
        
        AND
        
        $result = $dbconn->Execute($query);
        if (!$result) return;
        $invoices = array();
        while(!$result->EOF) {
            list($this->id) = $result->fields;
            $invoices[] = $this->id;
            $result->MoveNext();
        }
        return $invoices;
        </artwork>    
        <t>
        Check if a role already exists:
    </t>
      <artwork>
        Old code:
         
        $this-&gt;dbconn = xarDBGetConn();
        // Confirm that this group or user does not already exist
        if ($this->type == 1) {
            $query = "SELECT COUNT(*) FROM $this->rolestable
                  WHERE xar_name = '$this->name'";
        } else {
            $query = "SELECT COUNT(*) FROM $this->rolestable
                  WHERE xar_uname = '$this->uname'";
        }

        $result = $this->dbconn->Execute($query);
        if (!$result) return;

        list($count) = $result->fields;

        if ($count == 1) {//error message}
        
        
        New code: Note only the WHERE clause changes dpending on the role type
         
        // Confirm that this group or user does not already exist
        $q = new xarQuery('SELECT',$this->rolestable);
        if ($this->type == 1) {
            $q->eq('xar_name',$this->name);
        } else {
            $q->eq('xar_uname',$this->uname);
        }

        if (!$q->run()) return;

        if ($q->getrows() == 1) {//error message}
        </artwork>
    <t>
        Adding a group or user to the roles table
    </t>
      <artwork>
        Old code:
         
        $this-&gt;dbconn = xarDBGetConn();
        $nextId = $this->dbconn->genID($this->rolestable);
        $createdate = mktime();

        if ($this->type == 1) {
            $query = "INSERT INTO $this->rolestable
                        (xar_uid, xar_name, xar_type, xar_uname, xar_valcode, xar_date_reg)
                      VALUES (?, ?, ?, ?, ?, ?)";
            $bindvars = array(
                $nextId, 
                $this->name, 
                $this->type, 
                $this->uname, 
                $this->val_code,
                $createdate,
            );
        } else {
            $query = "INSERT INTO $this->rolestable
                        (xar_uid, xar_name, xar_type, xar_uname, xar_email, xar_pass,
                        xar_date_reg, xar_state, xar_valcode, xar_auth_module)
                      VALUES (?,?,?,?,?,?,?,?,?,?)";
            $bindvars = array(
                $nextId,
                $this->name,
                $this->type,
                $this->uname,
                $this->email,
                md5($this->pass),
                $createdate,
                $this->state,
                $this->val_code,
                $this->auth_module,
            );
        }
        // Execute the query, bail if an exception was thrown
        if (!$this->dbconn->Execute($query, $bindvars)) return;
        
        New code: Note the query is assembled incrementally
         
        $nextId = $this->dbconn->genID($this->rolestable);

        $tablefields = array(
            array('name' => 'xar_uid',      'value' => $nextId),
            array('name' => 'xar_name',     'value' => $this->name),
            array('name' => 'xar_uname',    'value' => $this->uname),
            array('name' => 'xar_date_reg', 'value' => mktime()),
            array('name' => 'xar_valcode',  'value' => $this->val_code)
        );
        $q = new xarQuery('INSERT',$this->rolestable);
        $q->addfields($tablefields);
        if ($this->type == 1) {
            $groupfields = array(
                array('name' => 'xar_type', 'value' => 1)
            );
            $q->addfields($groupfields);
        } else {
            $userfields = array(
                array('name' => 'xar_type',       'value' => 0),
                array('name' => 'xar_email',      'value' => $this->email),
                array('name' => 'xar_pass',       'value' => md5($this->pass)),
                array('name' => 'xar_state',      'value' => $this->state),
                array('name' => 'xar_auth_module','value' => $this->auth_module)
            );
            $q->addfields($userfields);
        }
        // Execute the query, bail if an exception was thrown
        if (!$q->run()) return;
        </artwork>
    </section>
    </section>

  </middle>

  <!-- Back matter is used for references and appendices which come after the references -->
  <back>
    <references title="Relevant References">

      <reference anchor="refs.0" target="http://www.ling.uni-potsdam.de/~moocow/projects/diplom/html-plain/node1.html">
        <front>
          <title>relational query feature structures</title>
          <author initials="B" surname="Jurish" fullname="Bryan Jurish">
            <organization></organization>
          </author>
          <date year="2001"/>
          <note title="earlier implementation in perl">
            <t>
              He tried to do what we want in Perl. Still to achive that he only made possible simple queries,
              where the Standard SQL is already the de facto needed abstraction.
            </t>
          </note>
        </front>
      </reference>

      <reference anchor="refs.1" target="http://www.objectwave.com/pdf/tools/JGrinder.pdf">
        <front>
          <title>ObjectWave JGrinder</title>
          <author initials="" surname="" fullname="">
            <organization>ObjectWave</organization>
          </author>
          <date year="2002"/>
          <note title="Proprietary Java implementation without much technical detail (vaporware?)">
            <t>
            </t>
          </note>
        </front>
      </reference>

      <reference anchor="refs.2" target="http://cobase-www.cs.ucla.edu/tech-docs/cqa.ps">
        <front>
          <title>CoBase: A Cooperative Database System</title>
          <author initials="W." surname="Chu" fullname="Wesley W. Chu">
            <organization>Computer Science Department University of California, Los Angeles</organization>
          </author>
          <author initials="Q." surname="Chen" fullname="Qiming Chen">
            <organization>Computer Science Department University of California, Los Angeles</organization>
          </author>
          <author initials="M." surname="Merzbacher" fullname="Matthew Merzbacher">
            <organization>Computer Science Department University of California, Los Angeles</organization>
          </author>
          <date year="2002"/>
          <note title="Cooperative Database System">
            <t>
                How having queries abstracted might help us communicate with future technology. We could
                create a CSQL driver for instance.
            </t>
          </note>
        </front>
      </reference>

      <reference anchor="refs.3" target="http://arxiv.org/abs/cs.db/0110044">
        <front>
          <title>EquiX--A Search and Query Language for XML</title>
          <author initials="S" surname="Cohen" fullname="Sara Cohen">
            <organization></organization>
          </author>
          <author initials="Y" surname="Kanza" fullname="Yaron Kanza">
            <organization></organization>
          </author>
          <author initials="Y" surname="Kogan" fullname="Yakov Kogan">
            <organization></organization>
          </author>
          <author initials="W" surname="Werner" fullname="Werner Nutt">
            <organization></organization>
          </author>
          <author initials="A" surname="Serebrenik" fullname="Alexander Serebrenik">
            <organization></organization>
          </author>
          <author initials="Y" surname="Sagiv" fullname="Yehoshua Sagiv">
            <organization></organization>
          </author>
          <date year="2003"/>
        <note title="proxy database">
          <t>
          </t>
        </note>
        </front>
      </reference>

      <reference anchor="refs.4" target="http://www.cs.duke.edu/~junyi/cps216/report.pdf">
        <front>
          <title>An Approach Towards Web Caching and Prefetching for Database Management Systems</title>
          <author initials="D" surname="Wang" fullname="Dazhi Wang">
            <organization>??</organization>
          </author>
          <author initials="J" surname="Xie" fullname="Junyi Xie">
            <organization>??</organization>
          </author>
          <date year="2003"/>
          <note title="proxy database">
            <t>
              Although the research is towards a proxy for the database system, our query abstraction
              could be able to modularly inform supposed proxies our query pattern / structure
              for better query prediction.
            </t>
          </note>
        </front>
      </reference>

      <reference anchor="refs.5" target="http://arxiv.org/ftp/cs/papers/0301/0301009.pdf">
        <front>
          <title>A Script Language for Data Integration in Database</title>
          <author fullname="Qingguo Zheng">
            <organization>National Lab. of Software Development Enviroment, Beihang University</organization>
          </author>
          <date year="2003"/>
          <note title="script language">
            <t>
                Script Language as a query abstraction.
            </t>
          </note>
        </front>
      </reference>

      <reference anchor="refs.6" target="http://marc.theaimsgroup.com/?l=php-dev&#38;m=101753543913458&#38;w=2">
        <front>
          <title>Relevant discussion about query abstraction</title>
          <author fullname="Daniel Lorch">
            <organization>PHP Devs</organization>
          </author>
          <date year="2002"/>
        </front>
      </reference>

      <reference anchor="refs.7" target="http://marc.theaimsgroup.com/?l=php-dev&#38;m=101752997709709&#38;w=2">
        <front>
          <title>Relevant discussion about query abstraction</title>
          <author fullname="Stig">
            <organization>PHP Devs</organization>
          </author>
          <date year="2002"/>
        </front>
      </reference>

      <reference anchor="refs.8" target="http://marc.theaimsgroup.com/?l=php-dev&#38;m=101740330610221&#38;w=2">
        <front>
          <title>Relevant discussion about query abstraction</title>
          <author fullname="Daniel Lorch">
            <organization>PHP Devs</organization>
          </author>
          <date year="2002"/>
        </front>
      </reference>

      <reference anchor="refs.9" target="http://marc.theaimsgroup.com/?l=php-db&#38;m=100635358202596&#38;w=2">
        <front>
          <title>PHP dev stating that a SQL parser should be the solution</title>
          <author fullname="Tomas V. V. Cox">
            <organization>PHP Devs</organization>
          </author>
          <date year="2002"/>
          <note title="parsing">
            <t>
              I personally think parsing SQL is the wrong way to do it.
              There are too many inconsistent ways to do it, not to say it would be an unnecessary complex solution.
            </t>
          </note>
        </front>
      </reference>

      <reference anchor="refs.10" target="http://pear.php.net/package-info.php?pacid=80&#38;release=0.13&#38;PHPSESSID=18e4b1d53db182aceeeb2c1e0b92e399">
        <front>
          <title>PEAR Package Data Object (for query abstraction)</title>
          <author fullname="">
            <organization></organization>
          </author>
          <date year="2002"/>
          <note title="class badly implemented">
            <t>
              The class doesnt fullfill our needs. Still there are things that can be reused.
            </t>
          </note>
        </front>
      </reference>

      <reference anchor="refs.11" target="http://px.sklar.com/code.html?id=239">
        <front>
          <title>SubSelect Emulation for Mysql</title>
          <author fullname="">
            <organization></organization>
          </author>
          <date year="2002"/>
          <note title="should have this feature">
            <t>
              This is one of the features our query abstraction should have. It shows how the abstraction
              can add value to the overall solution. Metabase implements it too.
            </t>
          </note>
        </front>
      </reference>

      <reference anchor="refs.12" target="http://www.oreilly.com/news/sqlnut_1200.html">
        <front>
          <title>Article showing difference between db queries</title>
          <author fullname="">
            <organization></organization>
          </author>
          <date year="2002"/>
          <note title="helpful article">
            <t>helpful for writing the drivers</t>
          </note>
        </front>
      </reference>


      <reference anchor="refs.13" target="http://www.javaworld.com/javaworld/jw-03-2002/jw-0301-dao-p2.html">
        <front>
          <title>DAO Pattern implentation in Java</title>
          <author fullname="">
            <organization></organization>
          </author>
          <date year="2002"/>
          <note title="Other atempts">
            <t>This DAO implementation PARSES(!) only very specifc SQL queries to abstract them. What is the point?</t>
          </note>
        </front>
      </reference>

      <reference anchor="refs.14" target="http://ccm.redhat.com/bboard-archive/acs_design/000818.html">
        <front>
          <title>Discussion about Query Abstraction in another CMS</title>
          <author fullname="">
            <organization></organization>
          </author>
          <date year="2002"/>
          <note title="Discussion right to the point">
            <t>Very insightful comments, read till the end.</t>
          </note>
        </front>
      </reference>

      <reference anchor="refs.15" target="http://www.joeyoder.com/papers/patterns/Reports/">
        <front>
          <title>Ideas on how to abstract SQL queries from 1997</title>
          <author fullname="">
            <organization></organization>
          </author>
          <date year="2002"/>
          <note title="SQL abstraction">
            <t>Too hardcoded to work out for us.</t>
          </note>
        </front>
      </reference>


      <reference anchor="refs.16" target="http://db.apache.org/ojb/">
        <front>
          <title>Apache Object Relational Mapper</title>
          <author fullname="">
            <organization></organization>
          </author>
          <date year="2002"/>
          <note title="SQL abstraction just like what i suggested">
            <t>A full Object Relational Mapper, with an SQL abstraction very close to what is suggested here</t>
          </note>
        </front>
      </reference>

      <reference anchor="refs.17" target="http://www.lap.ttu.ee/erki/failid/konspekt/bakalaureusetoo/thesis.pdf">
        <front>
          <title>Thesis on Object Relational Mapping</title>
          <author fullname="">
            <organization></organization>
          </author>
          <date year="2002"/>
          <note title="Thesis on the subject">
            <t>How to abstract all object operations thru a simple interface (CRUD)</t>
          </note>
        </front>
      </reference>




    </references>
    
    <!-- Any section after this will become an appendix -->
    <section title="Example appendix">
      <t>Any section which is present after the references will become an appendix</t>
    </section>
  </back>
</rfc>
