#!/bin/bash

# Override switch
if [ X$MT_RUNQA == Xno ]; then
exit 0
fi

# Cater for known differences between bsd/sysv style
SYSTEM=`uname`
case $SYSTEM in
    Darwin)
        TAILOPTS=""
        ;;
    *)
        TAILOPTS="-q"
        ;;
esac

# Prerequisites
monotone=`which monotone`
if [ X$monotone == X ]; then
    echo "Could not determine monotone location, aborting"
    exit 1
fi
# How to get a list of known files
# NOTE THE DOT HERE
lsknown="$monotone ls known ."

xmlparse=`which xmlparse`
if [ X$xmlparse == X ]; then
    echo "Could not determine location of custom Xaraya xmlparse script, aborting"
    exit 1
fi

# We need php for most of the checks
php=`which php`
if [ X$php == X ]; then
    echo "Could not determine php location, aborting"
    exit 1
fi

# Determine if a file contains non ascii characters
isascii() {
    # return 0 if $1 is an ascii file
    # return 1 otherwise
    # TODO: I dont know how to do this better
    (   typeInfo=`file -bi $1`
        case "$typeInfo" in
            image/*) exit 1;;
            application/x-gzip) exit 1;;
            application/x-zip) exit 1;;
            application/java) exit 1;;
            application/msword) exit 1;;
            application/pdf) exit 1;;
            application/octet-stream) exit 1;;
            audio/*) exit 1;;
            *) exit 0;; # assume ascii for the rest
        esac
    )
}

# Does an MT directory exist ? (path passed as $1)
mt_exists() {
    `ls $1/MT > /dev/null 2>&1`
    echo $?
}

# Determine the root of the current mt working dir, if any
mt_root () {
    # cd up in a subshell and break if we found an MT dir
    (   cd $1;
        while [ 1 == 1 ]; do
            MT_THERE=`mt_exists $PWD`
            if [ $MT_THERE -eq 0 ]; then
                echo $PWD; break;
            else
                cd ..
                if [ $PWD == / ]; then
                    break
                fi
            fi
        done
    )
}

# Now we can determine the working dir (root)
WORKDIR=`mt_root $PWD`
if [ X$WORKDIR == X ]; then
    # we could not find a working directory
    echo "Could not determine root of working directory, aborting"
    exit 1
fi
echo "Root of working dir determined as $WORKDIR"

# Assume all is well
cancommit=1

# Run this when a test fails
function failed() {
    # $1 test number
    # $2 msg
    # $3 result
    # $4 optional prefix to use
    echo
    echo "FAILED QA test $1: $test $2"
    if [ "X$4" != "X" ]; 
    then
        prefix=$4
    else
        prefix=" --> Line: "
    fi
    echo $prefix $3
    failed=1
    cancommit=0
}

# Run this when a test passes
function passed() {
    # $1 test number
    if [ $failed = 0 ] ; then
        echo "PASSED QA test $1: $test"
    fi
}
 
# Make sure all files are there
echo "Getting all necessary files..."
# what would we need to do here in monotone situation?

echo "Running some quality assurance checks on the files..."
echo

#
# GROUP 1: PHP Syntax related which will lead to errors
#
echo "--- Group 1: PHP syntax related checks ---"
# test 1.10 : parse errors are not allowed.
failed=0
test="PHP syntax check"
# NOTE THE DOT in the for test
for i in `$lsknown | grep ".php$"`; do
    # Test #1.1 : Is it a syntactically valid PHP file
    result=`$php -q -l -f $WORKDIR/$i`
    if [ $? -ne 0 ] ; then
      failed 1.10 "on $i" "$result"
    fi
done
passed 1.10


# test 1.11 Dont use short php tag
failed=0
test="No use of php short open tag '<?'"
for i in `$lsknown | grep ".php$"`; do
    result=`grep -in '<?[ ]*[^[xmlphpxar]*$' $WORKDIR/$i`
    if [ $? -ne 1 ] ; then
        failed 1.11 "in $i" $result
    fi
done
passed 1.11

# Last two characters of a php file are always ?>
failed=0
test="No other characters than ?> at the end of php file"
for i in `$lsknown | grep ".php$"`; do
    # skip empty files
    len=`wc -c $WORKDIR/$i`
    if [ "X$len" != "X0 $WORKDIR/$i" ] ; then
        result=`tail $TAILOPTS -c2 $WORKDIR/$i`
        result2=`tail $TAILOPTS -c3 $WORKDIR/$i`
        if [ "X$result" != 'X?>' ] ; then
            if [ "X$result2" != "X?>" ]; then
                failed 1.12 "on $i" "last two characters are '$result'"
            fi
        fi
    fi
done
passed 1.12


#
# GROUP 2: File conventions
echo "--- Group 2: File conventions ---"
# test 2.11 No tabs
failed=0
tab=`echo -en '\t'`
test="No use of tab characters in files"
for i in `$lsknown`; do
    # skip binary files
    ascii=`isascii $WORKDIR/$i`
    if [ $? -ne 1 ] ; then
        result=`grep -ce "$tab" $WORKDIR/$i`
        if [ $? -ne 1 ] ; then
            failed 2.11 "in $i" " n/a ($result tabs in file)"
        fi
    fi
done
passed 2.11

# test 2.13 : use unix line endings
failed=0
wincr=`echo -en '\r\n'`
test="No use of windows/mac line endings"
for i in `$lsknown`; do
    ascii=`isascii $WORKDIR/$i`
    if [ $? -ne 1 ] ; then  
        result=`grep -ce "$wincr" $WORKDIR/$i`
        if [ $? -ne 1 ] ; then
            failed 2.13 "on $i" " n/a (file has $result win/mac CRs)"
        fi
    fi    
done
passed 2.13

# Function use the one true brace convention
failed=0
test="Function declarations use one true brace"
for i in `$lsknown | grep ".php$"`; do
    result=`grep -n '[[:space:]]*function .*[(].*[)].*{.*' $WORKDIR/$i`
    if [ $? -ne 1 ] ; then
        failed 2.18 "in $i" $result
    fi
done
passed 2.18 

# Class declations use the one true brace convention
failed=0
test="Class declarations use one true brace"
for i in `$lsknown | grep ".php$"`; do
    result=`grep -n '^[[:space:]]*class .*{.*' $WORKDIR/$i`
    if [ $? -ne 1 ] ; then
        failed 2.19 "in $i" $result
    fi
done
passed 2.19


# 
# GROUP 3: Functional / Related to XARAYA
#
has_deprecated_func() {
    # $1 is the filename to check
    # $2 is the deprecated function name
    # the first part greps the usage, where the second part ignores the definition
    result=`grep -in ".*$2[ ]*(" $1 | grep -vi "function[ ]*$2[ ]*("`
    return $?
}

echo "--- Group 3: Deprecation ---"
# xarExceptionMajor is deprecated
failed=0
test="No use of xarExceptionMajor"
for i in `$lsknown | grep ".php$"`; do
    result=`has_deprecated_func $WORKDIR/$i "xarexceptionmajor"`
    if [ $? -ne 1 ] ; then
        if [ "$(basename $i)" != "xarLegacy.php" ]; then
            failed 3.10 "in $i" $result
        fi
    fi
done
passed 3.10

# xarExceptionSet is deprecated
failed=0
test="No use of xarExceptionSet"
for i in `$lsknown | grep ".php$"`; do
    result=`has_deprecated_func $WORKDIR/$i "xarexceptionset"`
    if [ $? -ne 1 ] ; then
        if [ "$(basename $i)" != "xarLegacy.php" ]; then
            failed 3.11 "in $i" $result
        fi
    fi
done
passed 3.11

# xarVarCleanFromInput is deprecated
failed=0
test="No use of xarVarCleanFromInput (use xarVarFetch)"
for i in `$lsknown | grep ".php$"`; do
    result=`has_deprecated_func $WORKDIR/$i "xarvarcleanfrominput"`
    if [ $? -ne 1 ] ; then
        failed 3.12 "in $i" $result
    fi
done
passed 3.12

# xarVarPrepForStore is deprecated
failed=0
test="No use of xarVarPrepForStore (use bindvars or qstr method)"
for i in `$lsknown | grep ".php$"`; do
    result=`has_deprecated_func $WORKDIR/$i "xarvarprepforstore"`
    if [ $? -ne 1 ] ; then
        if [ "$(basename $i)" != "xarLegacy.php" ]; then
            failed 3.10.4 "in $i" $result
        fi
    fi
done
passed 3.13

# xarExceptionId is deprecated
failed=0
test="No use of xarExceptionID (use xarCurrentErrorId)"
for i in `$lsknown | grep ".php$"`; do
    result=`has_deprecated_func $WORKDIR/$i "xarexceptionid"`
    if [ $? -ne 1 ] ; then
        if [ "$(basename $i)" != "xarLegacy.php" ]; then
            failed 3.14 "in $i" $result
        fi
    fi
done
passed 3.14

# xarExceptionValue is deprecated
failed=0
test="No use of xarExceptionValue (use xarCurrentError)"
for i in `$lsknown | grep ".php$"`; do
    result=`has_deprecated_func $WORKDIR/$i "xarexceptionvalue"`
    if [ $? -ne 1 ] ; then
        if [ "$(basename $i)" != "xarLegacy.php" ]; then
            failed 3.15 "in $i" $result
        fi
    fi
done
passed 3.15

# xarExceptionFree is deprecated
failed=0
test="No use of xarExceptionFree (use xarErrorFree)"
for i in `$lsknown | grep ".php$"`; do
    result=`has_deprecated_func $WORKDIR/$i "xarexceptionfree"`
    if [ $? -ne 1 ] ; then
        if [ "$(basename $i)" != "xarLegacy.php" ]; then
            failed 3.16 "in $i" $result
        fi
    fi
done
passed 3.16

# xarExceptionHandled is deprecated
failed=0
test="No use of xarExceptionHandled (use xarErrorHandled)"
for i in `$lsknown | grep ".php$"`; do
    result=`has_deprecated_func $WORKDIR/$i "xarexceptionhandled"`
    if [ $? -ne 1 ] ; then
        if [ "$(basename $i)" != "xarLegacy.php" ]; then
            failed 3.17 "in $i" $result
        fi
    fi
done
passed 3.17

# xarExceptionRender is deprecated
failed=0
test="No use of xarExceptionRender (use xarErrorRender)"
for i in `$lsknown | grep ".php$"`; do
    result=`has_deprecated_func $WORKDIR/$i "xarexceptionrender"`
    if [ $? -ne 1 ] ; then
        if [ "$(basename $i)" != "xarLegacy.php" ]; then
            failed 3.18 "in $i" $result
        fi
    fi
done
passed 3.18

# Use of ---> is not allowed
echo "--- XML syntax ---"
failed=0
test="No use of ---> in templates"
for i in `$lsknown | grep "\.x[dt]$"`; do
    result=`grep -n '\-\-\->' $WORKDIR/$i`
    if [ $? -ne 1 ] ; then
        failed 4.10 "in $i" $result
    fi
done
passed 4.10

# Check well formedness of templates
failed=0
test="Only well formed XML in templates (each dot = 1 file)"
for i in `$lsknown | grep "\.x[dt]$"`; do
    echo -n "."
    result=`$xmlparse $WORKDIR/$i`
    
    if [ $? -ne 0 ] ; then
        failed 4.11 "in $i" " " " --> Results:"
        echo "$result"
    fi
done
echo "."
passed 4.11

if [ $cancommit -eq 0 ] ; then
    echo 
    echo "PUSH ABORTED:"
    echo "I'm sorry, some QA tests failed, i cannot commit these changes"
    echo "Look at the failures above and fix those first, after that, try again"
    # exit with code 1, dont even leave something behind
    exit 1
fi

# echo "All seems well, continuing to apply the changes"
exit 0
