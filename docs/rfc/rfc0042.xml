<?xml version="1.0" encoding="iso-8859-1"?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xsl"?>
    <!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<!-- 
    Supported processing instructions, uncomment the ones you want
-->

<!-- <?rfc private="my private memo"?>  Produce a private memo rather than a Xaraya-standard --> 
<!-- <?rfc editing="yes"?>  Insert a number in each paragraph to ease review comments -->
<!-- <?rfc symrefs="yes"?>  Instead of numeric cross references, use the sections name -->
<!-- <?rfc sortrefs="yes"?> Sort the references -->
<!-- <?rfc parse-xml-in-artwork="yes" ?> Do we want xml is artwork sections parsed (only uncomment if you know what that means) -->
<!-- <?rfc tocdepth="2"?>  How many levels should be displayed in the TOC (default: 99 -->

<!-- I guess we always want a table of contents -->
<?rfc toc="yes"?>
<?rfc editing="yes"?>

<rfc xmlns:ed="http://greenbytes.de/2002/rfcedit" number="0042" category="bcp">
  <!-- number: Fill in the number for the RFC -->
  <!-- obsoletes: Comma separated list of RFC numbers which this one obsoletes -->
  <!-- category: std=standard, bcp=best common practice, info=info, exp=experimental, historic=historic -->
  
  <!-- Front matter is used for identification of author and organization -->
  <front>
    <title>Module hooks system</title>
    <author initials="M.R." surname="van der Boom" fullname="Marcel van der Boom">
      <organization>Xaraya Development Group</organization>
      <address>
        <email>marcel@hsdev.com</email>
        <uri>http://www.xaraya.com</uri>
      </address>
    </author>
    <date month="Februari" year="2003"/>
    
    <!-- Initiating team for this RFC -->
    <workgroup>Project Management Committee</workgroup>
    
    <!-- List keywords for the RFC here -->
    <keyword>rfc</keyword>
    <keyword>template</keyword>
    
    <!-- The abstract summarizes in one or two paragraphs the content of the RFC -->
    <abstract>
      <t>This RFC documents the hooks system for Xaraya. We have a hooks system in place, but
        undocumented. This RFC should resolve that by at least documenting what we have now.
      </t>
    </abstract>
  </front>
  
  <!-- The middle section is used for the actual content of the RFC -->
  <middle>
    <!-- Introduction is mandatory -->
    <section title="Introduction">
        <t>The hook system allows site administrators to extend the functionality of modules - with
           common features like comments, hitcounts, ratings, support for BBCode or Wiki etc.</t>
        <t>Those features are provided by so-called hook modules : utility modules that offer a
           number of hook functions, that will be called automatically when the corresponding hooks are enabled.</t>
        <t>The main difference between hook calls and regular API calls is that hook calls to a
           particular hook function (e.g. to display comments) are not hard-coded in the module
           itself, but you can turn them on and off again via the administration.</t>
        <t>This gives you a much greater flexibility, both as a site administrator and as a module
           developer, in terms of the optional features that you want to provide in different parts
           of your site or in your module.</t>
    </section>

    <!-- One content section is mandatory -->
    <section title="Types of hooks">
        <t>There are 5 main types of hooks that are currently used to extend module functionality, plus some special-purpose hooks.
           Some hooks will provide part of the graphical user interface (GUI) to the user, while others will only operate on the API level.</t>

            <section title="Item Transform Hooks (API)">
                <t>This type of hook allows you to transform some pieces of text of your module items
                   (e.g. the summary and body of articles, or the description of a project, ...)
                   in different ways, depending on the hook modules that are enabled for it.
                   Hook modules that provide this type of hooks are for instance bbcode, autolinks, wiki, ...</t>
            </section>
            <section title="Item Display Hooks (GUI)">
                <t>This type of hook shows some additional information that relates to a particular
                   module item when that item is being displayed. Typical examples include comments, hitcount, ratings, ...</t>
            </section>
            <section title="Item Create/Update/Delete Hooks (API)">
                <t>Some hook modules follow the whole life cycle of module items, from the moment the item is created,
                   through any updates it may have, and up to the point where the item is deleted again.</t>
                <t>In some cases, like the hitcount or ratings module, those hooks are only used to keep track of some
                   internal value for each module item. In other cases, like for categories and dynamicdata, the hook
                   module will also provide a graphical interface - see next type of hook.</t>
            </section>
            <section title="Item New/Modify Hooks (GUI)">
                <t>This type of hook extends the previous one by showing some additional input fields in forms where module
                   items are added or modified. This allows you to e.g. assign a module item to a particular category,
                   or to fill in some dynamic properties for that item, etc.</t>
                <t>The corresponding values will then be saved or updated when the item is created/updated.</t>
            </section>
            <section title="Module Configuration Hooks (GUI/API)">
                <t>Some hook modules, like categories and dynamicdata, also offer specific configuration options
                   for each module that is hooked to them. This type of hook will automatically insert those options
                   within the rest of the module configuration screen, and update them when the module configuration itself is being updated.</t>
            </section>
            <section title="Special-Purpose Hooks : Search, UserMenu, WaitingContent, ...">
                <t>All the hook types described above provide some common add-on features that can be used to extend different modules.
                   So a utility module like autolinks, that provides an Item Transform hook, can be used by any module that calls the standard Item Transform hooks, e.g. in articles, xproject, xarbb, ...</t>
                <t>There is another type of hooks that works the other way around : those hooks are only called in one particular place, by one particular module,
                   and other modules that provide this hook function will only extend this particular functionality.</t>
                <t>One example of this is the Item Search hook, which is used by the search module to call any hook function (from any module) that provides a search interface.
                   So the articles module may provide a search hook function, and the xarbb module may provide one, and the roles module as well, and it's up to the site administrator
                   to decide which search functions he wants to allow by enabling the corresponding hooks.</t>
                <t>Another example is the UserMenu hook, which is used by the roles module to call any hook function that provides a user menu, for integration in "Your Account".
                   So the articles module may provide a user menu function, and the xarbb module may provide one, and the roles module as well, and it's up to the site administrator
                   to decide which user menu functions he wants to allow by enabling the corresponding hooks.</t>
                <t>The WaitingContent hook is another example, which is used by the adminpanels module to call any hook function that provides a list of waiting content, for use in the waitingcontent block.
                   So the articles module may provide a list of waiting content, and the xarbb module may provide one, and the polls module as well, and it's up to the site administrator
                   to decide which waiting content he wants to see by enabling the corresponding hooks.</t>
                <t>The Module Remove hook functions are called by Xaraya when a particular module is being removed, so that hook modules can perform some clean-up of their own table(s) if necessary.</t>
            </section>
    </section>
    
    <section title="Enabling or disabling hooks">
        <t>Site administrators can enable hooks via the Modules administration :
           <list style="symbols">
           <t>if you want to enable some hooks for a particular module (e.g. articles), you can do that via Modules -&gt; View All -&gt; extend that particular module</t>
           <t>if on the other hand, you want to enable/disable a particular hook (e.g. comments) for several modules at once (e.g. articles, example, polls, ...), you should do that via Modules -&gt; Configure hooks -&gt; choose that particular hook module</t>
           </list>
        </t>
        <t>If you want to enable or disable hooks via code, see also below.</t>
        <t>Note : some modules handle more than one type of items (e.g. articles has different publication types), and you may want to enable hooks for one particular item type in that module. You can do this in the Modules administration as well.</t>
    </section>

    <section title="Designing your module to make use of hooks">
        <t>Insert xarModCallHooks() in all the right places - cfr. example module.  // TODO: improve the parameters</t>
        <t>The syntax of the xarModCallHooks() function is as follows :
           <artwork>
$outputarray = xarModCallHooks('&lt;hookobject&gt;', '&lt;hookaction&gt;', $objectid, $extrainfo);
           </artwork></t>
        <t>In general, API hooks expect an associative array containing the current item information as $extrainfo,
           and return that array with extended or transformed information.
           GUI hooks expect the same item information as $extrainfo, and return an associative array of hookmodule => hookoutput pairs        </t>
        <t>By default, hooks are always called for the current "main module". If you need to call the hooks for another module, e.g. in a block or API function,
           you can specify the caller module in $extrainfo['module']. If your module deals with different item types, you should pass on the
           currently relevant item type via $extrainfo['itemtype'].</t>

            <section title="Calling Item Transform Hooks (API)">
                    <artwork>
Module code in xaruser.php :

function &lt;module&gt;_user_display($args)
{
    ...
    // get the item information
    $item = xarModAPIFunc('&lt;module&gt;', 'user', 'get',
                          array('someid' => $itemid, ...));
    ...
    // add some arguments for hooks
    $item['module'] = '&lt;module&gt;';
    $item['itemtype'] = $itemtype;
    ...
/* old-style transform hooks
    list($item['some'],
         $item['pieces'],
         $item['of'],
         $item['text']) = xarModCallHooks('item', 'transform', $itemid,
                                          // the pieces of text you want to transform here
                                          array($item['some'],
                                                $item['pieces'],
                                                $item['of'],
                                                $item['text']));
*/
    // the fields (array keys) corresponding to the pieces of text you want to transform here
    $item['transform'] = array('some', 'pieces', 'of', 'text');

    // transform item
    $item = xarModCallHooks('item', 'transform', $itemid, $item);
    ...
}
                    </artwork>
            </section>

            <section title="Calling Item Display Hooks (GUI)">
                    <artwork>
Module code in xaruser.php :

function &lt;module&gt;_user_display($args)
{
    ...
    // get the item information
    $item = xarModAPIFunc('&lt;module&gt;', 'user', 'get',
                          array('someid' => $itemid, ...));
    ...
    // add some arguments for hooks
    $item['module'] = '&lt;module&gt;';
    $item['itemtype'] = $itemtype;
    ...
/* old-style display hooks
    $hookoutput = xarModCallHooks('item', 'display', $itemid,
                                  // the URL to return to e.g. after rating the item, or commenting on it, or ...
                                  xarModURL('&lt;module&gt;', 'user', 'display',
                                            array('someid' =&gt; $itemid, ...))
                                 );
*/
    // the URL to return to e.g. after rating the item, or commenting on it, or ...
    $item['returnurl'] = xarModURL('&lt;module&gt;', 'user', 'display',
                                   array('someid' =&gt; $itemid, ...));
    // get display hook output
    $hookoutput = xarModCallHooks('item', 'display', $itemid, $item);

    if (empty($hookoutput)) {
       $data['hooks'] = '';
    } elseif (is_array($hookoutput)) {
        // $hookoutput['comments'] contains the hook output for comments,
        // $hookoutput['hitcount'] contains the hook output for the hitcount,
        // $hookoutput['ratings'] contains the hook output for ratings, and so on...

        // you can use them individually in the template, or join everything together
        $data['hooks'] = join('',$hookoutput);
    } else {
        // this will no longer be relevant
        $data['hooks'] = $hookoutput;
    }
    ...
}
                    </artwork>
            </section>

            <section title="Calling Item Create/Update/Delete Hooks (API)">
                    <artwork>
Module code in xaradminapi.php :

function &lt;module&gt;_adminapi_create($args)
{
    ...
    // create the item first
    ...
    // then add some arguments for hooks, including the newly created itemid
    $args['module'] = '&lt;module&gt;';
    // adapt if you're dealing with several types of items in your module
    $args['itemtype'] = 0;
    $args['itemid'] = $itemid;
    // then call the create hooks
    $result = xarModCallHooks('item', 'create', $itemid, $args);
    ...
}

function &lt;module&gt;_adminapi_update($args)
{
    ...
    // update the item first
    ...
    // then add some arguments for hooks
    $args['module'] = '&lt;module&gt;';
    // adapt if you're dealing with several types of items in your module
    $args['itemtype'] = 0;
    $args['itemid'] = $itemid;
    // then call the update hooks
    $result = xarModCallHooks('item', 'update', $itemid, $args);
    ...
}

function &lt;module&gt;_adminapi_delete($args)
{
    ...
    // add some arguments for hooks
    $args['module'] = '&lt;module&gt;';
    // adapt if you're dealing with several types of items in your module
    $args['itemtype'] = 0;
    $args['itemid'] = $itemid;
    // then call the delete hooks
    $result = xarModCallHooks('item', 'delete', $itemid, $args);
    ...
    // then delete the item itself at last
    ...
}
                    </artwork>
            </section>

            <section title="Calling Item New/Modify Hooks (GUI)">
                    <artwork>
Module code in xaradmin.php :

function &lt;module&gt;_admin_new($args)
{
    ...
    // we have no item information here yet
    $item = array();
    // we don't have an item id yet either
    $itemid = '';
    ...
    $item['module'] = '&lt;module&gt;';
    // adapt if you're dealing with several types of items in your module
    $item['itemtype'] = 0;
    $item['itemid'] = $itemid;

    $hookoutput = xarModCallHooks('item', 'new', $itemid, $item);
    if (empty($hookoutput)) {
        $data['hooks'] = '';
    } elseif (is_array($hookoutput)) {
        // $hookoutput['categories'] contains the hook output for categories,
        // $hookoutput['dynamicdata'] contains the hook output for dynamicdata, and so on...

        // you can use them individually in the template, or join everything together
        $data['hooks'] = join('',$hookoutput);
    } else {
        // this will no longer be relevant
        $data['hooks'] = $hookoutput;
    }
    ...
}

function &lt;module&gt;_admin_modify($args)
{
    ...
    // get the item information
    $item = xarModAPIFunc('&lt;module&gt;', 'user', 'get',
                          array('someid' => $itemid, ...));
    ...
    $item['module'] = '&lt;module&gt;';
    // adapt if you're dealing with several types of items in your module
    $item['itemtype'] = 0;
    $item['itemid'] = $itemid;

    $hookoutput = xarModCallHooks('item', 'modify', $itemid, $item);
    if (empty($hookoutput)) {
        $data['hooks'] = '';
    } elseif (is_array($hookoutput)) {
        // $hookoutput['categories'] contains the hook output for categories,
        // $hookoutput['dynamicdata'] contains the hook output for dynamicdata, and so on...

        // you can use them individually in the template, or join everything together
        $data['hooks'] = join('',$hookoutput);
    } else {
        // this will no longer be relevant
        $data['hooks'] = $hookoutput;
    }
    ...
}
                    </artwork>
            </section>

            <section title="Calling Module Configuration Hooks (GUI/API)">
                    <artwork>
Module code in xaradmin.php :

function &lt;module&gt;_admin_modifyconfig($args)
{
    ...
    $extrainfo = array();
    $extrainfo['module'] = '&lt;module&gt;';
    // adapt if you're dealing with several types of items in your module
    $extrainfo['itemtype'] = 0;

    $hookoutput = xarModCallHooks('module', 'modifyconfig', '&lt;module&gt;', $extrainfo);
    if (empty($hookoutput)) {
        $data['hooks'] = '';
    } elseif (is_array($hookoutput)) {
        // $hookoutput['categories'] contains the hook output for categories,
        // $hookoutput['dynamicdata'] contains the hook output for dynamicdata, and so on...

        // you can use them individually in the template, or join everything together
        $data['hooks'] = join('',$hookoutput);
    } else {
        // this will no longer be relevant
        $data['hooks'] = $hookoutput;
    }
    ...
}

function &lt;module&gt;_admin_updateconfig($args)
{
    ...
    $extrainfo = array();
    $extrainfo['module'] = '&lt;module&gt;';
    // adapt if you're dealing with several types of items in your module
    $extrainfo['itemtype'] = 0;

    $result = xarModCallHooks('module', 'updateconfig', '&lt;module&gt;', $extrainfo);
    ...
}
                    </artwork>
            </section>
            <section title="Providing Special-Purpose Hooks : Search, UserMenu, WaitingContent, ...">
                 <t>In this case, you'll need to create a hook function and register it at initialisation - see next section</t>
            </section>

            <section title="Other hook-related functions">
                <t>You can check if a particular hook module is enabled for your module by using the xarModIsHooked() function :
                    <artwork>
   ...
   if (xarModIsHooked('&lt;hookmodule&gt;')) {
   }
   ...
                    </artwork>
                    If you want to use this in places where your module may not be the current "main module", e.g. in blocks or API functions,
                    you should specify the caller module as an extra parameter :
                    <artwork>
   ...
   if (xarModIsHooked('&lt;hookmodule&gt;', '&lt;yourmodule&gt;')) {
   }
   ...
                    </artwork>
                    And if you want to check if a hook is enabled for a particular item type in your module, you should specify the item type
                    as the third argument :
                    <artwork>
   ...
   if (xarModIsHooked('&lt;hookmodule&gt;', '&lt;yourmodule&gt;', $thistype)) {
   }
   ...
                    </artwork>
                </t>
                <t>You can enable hooks to your module via code, e.g. at initialisation, by using one of the API functions provided by the 'modules' module :
                    <artwork>
   ...
    xarModAPIFunc('modules', 'admin', 'enablehooks',
                  array('callerModName' => '&lt;yourmodule&gt;', 'hookModName' => '&lt;hookmodule&gt;'));
   ...
                    </artwork>
                </t>
                <t>To disable hooks via code, you can use the corresponding function as well :
                    <artwork>
   ...
    xarModAPIFunc('modules', 'admin', 'disablehooks',
                  array('callerModName' => '&lt;yourmodule&gt;', 'hookModName' => '&lt;hookmodule&gt;'));
   ...
                    </artwork>
                   To specify a particular item type in one of those two functions, you can use the extra parameter 'callerItemType' here.
                </t>
            </section>

    </section>

    <section title="Providing hook functions in your module">
        <t>Decide what functionality you want to offer first, then see what type(s) of hooks you need to provide for that...</t>
        <t>Please note that your hook function may be called by modules other than the current "main module", so you should check for any optional $extrainfo['module']
           parameter if your hook module stores information regarding particular modules or module items. Some modules calling your hook functions might also be handling
           several item types, which they will pass as an optional $extrainfo['itemtype'] parameter. So your module should take into account that item type as well, if
           relevant.</t>
            <section title="Writing an API hook function">
                 <artwork>
Module code in xaruserapi.php or xaradminapi.php :

/**
 * The hook function you want to provide, e.g. for 'item' 'transform' 'API'
 *
 * @param $args['objectid'] ID of the object
 * @param $args['extrainfo'] extra information
 * @returns array
 * @return extrainfo the updated extrainfo array
 */
function &lt;module&gt;_&lt;type&gt;api_&lt;hookfunc&gt;($args)
{
    ...
}
                 </artwork>
            </section>

            <section title="Writing a GUI hook function">
                 <artwork>
Module code in xaruser.php or xaradmin.php :

/**
 * The hook function you want to provide, e.g. for 'item' 'display' 'GUI'
 *
 * @param $args['objectid'] ID of the object
 * @param $args['extrainfo'] extra information
 * @returns string
 * @return the HTML output for this hook function
 */
function &lt;module&gt;_&lt;type&gt;_&lt;hookfunc&gt;($args)
{
    ...
}
                 </artwork>
            </section>

            <section title="Registering hook functions">
                 <artwork>
Module code in xarinit.php :

function &lt;module&gt;_init()
{
    ...
    xarModRegisterHook(// the type of hook you want to register
                       'item', 'display', 'GUI',
                       // the hook function to be called
                       '&lt;module&gt;', '&lt;type&gt;', '&lt;hookfunc&gt;');
    ...
}

function &lt;module&gt;_delete()
{
    ...
    xarModUnregisterHook(// the type of hook you want to unregister
                         'item', 'display', 'GUI',
                         // the hook function to be called
                         '&lt;module&gt;', '&lt;type&gt;', '&lt;hookfunc&gt;');
    ...
}
                 </artwork>
            </section>

            <section title="Creating a Search hook function (GUI)">
                 <t>A search hook function is only going to be invoked by the search module. Next to the standard $args['objectid'] and $args['extrainfo'] arguments,
                    which are not going to contain anything interesting here, your search hook function will be able to retrieve the current search query via the input variable 'q'.</t>
                     <artwork>
Module code in xaruser.php :

/**
 * The hook function you want to provide for 'item' 'search' 'GUI'
 *
 * @param $args['objectid'] ID of the object
 * @param $args['extrainfo'] extra information
 * @returns string
 * @return the HTML output for this hook function
 */
function &lt;module&gt;_user_search($args)
{
    list($q,
         $author,
         $...) = xarVarCleanFromInput('q',
                                      'author',
                                      '...');
    if (empty($q)) {
        // return part of a search form, with input fields relevant to your module
        ...
    } else {
        // return the results for your module
        ...
    }
}
                     </artwork>
                 <t>You can add other input fields of your own in the GUI output, but make sure they don't create a conflict with input fields from other modules.
                    Note that the same function will be invoked by the search module to show (part of) the search form, but also to show (part of) the result page.</t>
            </section>

            <section title="Creating a User Menu hook function (GUI)">
                 <t>A user menu hook function is only going to be invoked by the roles module, to generate some user menu in the "Your Account" page.
                    You can use this e.g. to allow users to change their preferences for your module from within the "Your Account" page.</t>
                     <artwork>
Module code in xaruser.php :

/**
 * The hook function you want to provide for 'item' 'usermenu' 'GUI'
 *
 * @param $args['objectid'] ID of the object
 * @param $args['extrainfo'] extra information
 * @returns string
 * @return the HTML output for this hook function
 */
function &lt;module&gt;_user_usermenu($args)
{
    list($update,
         $bold,
         $itemsperpage,
         $...) = xarVarCleanFromInput('update',
                                      'bold',
                                      'itemsperpage',
                                      '...');
    if (!empty($update)) {
        // update the user preferences
        if (isset($bold)) {
            xarModSetUserVar('&lt;module&gt;', 'bold', 1);
        } else {
            xarModSetUserVar('&lt;module&gt;', 'bold', 0);
        }
        ...
    } else {
        // get the current user preferences
        $bold = xarModGetUserVar('&lt;module&gt;', 'bold');
        ...
    }
    // show an input form where the user can change his preferences for your module
    // Tip : include a hidden field called 'update' in the form, so that you know
    //       when to update the user preferences, and when to simply show them
    ...
}
                     </artwork>
                 <t>Note that the same function will be invoked by the roles module to show the current preferences of the user, and also to update them.</t>
            </section>

            <section title="Creating a Module Remove hook function (API)">
                 <t>If your hook module keeps track of some information for module items of different modules, you may want to do some clean-up in your own table(s)
                    when some hooked module gets deleted by the site administrator. In this case, you can define a 'module' 'remove' 'API' function
                    that will be automatically invoked by Xaraya.</t>
                 <artwork>
Module code in xaradminapi.php :

/**
 * The hook function you want to provide for 'module' 'remove' 'API'
 *
 * @param $args['objectid'] ID of the object
 * @param $args['extrainfo'] extra information
 * @returns array
 * @return extrainfo the updated extrainfo array
 */
function &lt;module&gt;_adminapi_removehook($args)
{
    extract($args);
    ...
    // in this case, $objectid will contain the name of the module that is being removed
    $modid = xarModGetIDFromName($objectid);
    // do some clean-up in your table(s) for that module
    ...
}
                 </artwork>
            </section>
    </section>

    <section title="When (not) to use hooks">
        <t>Comparison with API calls and the event system...</t>
    </section>

    <section title="Implementation Details">
        <t>Current stuff in the core and modules module...</t>
    </section>

    <section title="Future Evolution">
        <t>One major drawback of the current hook types is that most of the hooked functionality can only be used when you're
           dealing with individual module items, not when you're dealing with several items at once. So you can't easily select
           module items based on some hooked information, or show some hooked information when viewing a list of items.</t>
        <t>In order to provide the same kind of functionality when dealing with more than one module item, we can't simply
           add some GUI output in a list - we need some way to integrate the data retrieval from those "loosely coupled" hook
           modules with the data retrieval for the module items themselves, or work on the API and/or BL level to achieve the same thing.</t>
        <t>A first approach to address this issue -used by the articles module at the moment (March 2003)- consisted of making the module
           "aware" of several commonly used hooks, and to include the data retrieval and GUI integration for those hooks in the module code.
           This solves the immediate problem of integrating certain hooks when dealing with lists of articles, and still allows you to enable
           or disable those hooks via administration, but it goes against the idea of "loose coupling" and requires extensive code in the module itself.</t>
        <t>A more generic approach -for use by any module- is being investigated on the data access level. Whether this will be limited to
           some kind of "SQL hooks", or will cover the whole issue of data access to module items together with their "related" information
           is still being explored at the moment. Either way, some changes are to be expected in the hook calls in the future.</t>
    </section>

    <!-- Revision history is mandatory -->
    <section title="Revision history">
      <t>2003-06-28: Add comments on how to call hooks on behalf of a particular module, and how to specify the item type (if any)</t>
      <t>2003-03-27: Start filling in some sections</t>
      <t>2003-02-27: Created</t>
    </section>
    
  </middle>
  
  <!-- Back matter is used for references and appendices which come after the references -->
  <back>
   
    <!-- Any section after this will become an appendix -->

  </back>
</rfc>
