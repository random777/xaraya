<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
<!ENTITY documentinfo SYSTEM "parts/document_info.xml">
<!ENTITY preface SYSTEM "parts/preface.xml">
<!ENTITY introduction SYSTEM "parts/introduction.xml">
<!ENTITY xaraya_module_architecture SYSTEM "parts/xaraya_module_architecture.xml">
<!ENTITY create_your_module SYSTEM "parts/create_your_module.xml">
<!ENTITY understanding_hooks SYSTEM "parts/understanding_hooks.xml">
<!ENTITY bibliography SYSTEM "parts/bibliography.xml">
<!ENTITY glossary SYSTEM "parts/glossary.xml">
]>
<book>
  <!-- Meta info about this document -->
  &documentinfo;

  <!-- Preface -->
  &preface;

  <!-- Introduction -->
  &introduction;

  <chapter>
    <title>Xaraya Architecture</title>

    <para>This chapter describes the basic architecture of Xaraya, explains
    the major parts, and contains information on the design choices made for
    the system. It describes how basic parts of Xaraya operate and what you
    can expect from Xaraya Core.</para>

    <section>
      <title>Block lay-out</title>

      <para>Explanation of Block Lay-out in Xaraya</para>
    </section>

    <section>
      <title>Xaraya API</title>

      <para>Reference type of text</para>
    </section>

    <section>
      <title>Core modules</title>

      <para>What Core modules are there, what can you use</para>
    </section>

    <section>
      <title>Blocks</title>

      <para></para>
    </section>

    <section>
      <title>Variable Handling</title>

      <para>Variables are loaded through xarVarFetch calls in order to be
      processed, checked for validity, as well as proper handling on unset
      vars, etc. Instead of relying on $_POST or $_GET calls throughout your
      module and then cleaning the input, Xaraya has a very robust way of
      handling the variable. You can process parameters in your function via
      the function itself as well. This is normally done by API functions, as
      parameters present in the environment can be different from the ones
      passed to these variables.</para>

      <para>An example call would be: <code>
          if (!xarVarFetch('itemsperpage', 'int', $itemsperpage, 10, XARVAR_NOT_REQUIRED)) return;
        </code></para>

      <para>This fetches the <varname>$itemsperpage</varname> variable from the input variable
      'itemsperpage' and validates it by applying the $validation rules, in
      this case it being an integer.</para>

      <para>The functions works in this order:</para>

      <para>First try to use the variable provided (itemsperpage), if this is
      not set (or the XARVAR_DONT_REUSE flag is used) then it tries to get the
      variable from the input (POST/GET methods for now). It then tries to
      validate the variable through xarVarValidate with the validation of
      'int' (integer).</para>

      <para>After the call the <varname>$value</varname> parameter is passed by reference is set
      to the variable value converted to the proper type according to the
      validation applied.</para>

      <para>The $defaultValue provides a default value that is returned when
      the variable is not present or doesn't validate correctly.</para>

      <para>
        The <varname>$flag</varname> parameter is a bitmask between the following
        constants:
        <itemizedlist>
          <listitem><para><constant>XARVAR_GET_OR_POST</constant></para></listitem>
          <listitem><para><constant>XARVAR_GET_ONLY</constant></para></listitem>
          <listitem><para><constant>XARVAR_POST_ONLY</constant></para></listitem>
          <listitem><para><constant>XARVAR_NOT_REQUIRED</constant></para></listitem>
        </itemizedlist>
        You can force to get the variable only from GET parameters or POST
        parameters by setting the <varname>$flag</varname> parameter
        to one of <constant>XARVAR_GET_ONLY</constant> or
        <constant>XARVAR_POST_ONLY</constant>.
      </para> 

      <para>
        You can force xarVarFetch not to reuse the variable by setting the
        <varname>$flag</varname> parameter to
        <constant>XARVAR_DONT_REUSE</constant>.
      </para>

      <para>By default $flag is XARVAR_GET_OR_POST which means that
      xarVarFetch will lookup both GET and POST parameters and that if the
      variable is not present or doesn't validate correctly an exception will
      be raised.</para>

      <para>
        The <varname>$prep</varname> flag will prepare <varname>$value</varname> by passing it to one of the
        following:
        <itemizedlist>
          <listitem><para><constant>XARVAR_PREP_FOR_NOTHING</constant>:
          no prep (default)</para></listitem>
          <listitem>
            <para>
              <constant>XARVAR_PREP_FOR_DISPLAY</constant>: 
              <function>xarVarPrepForDisplay(<varname>$value</varname>)</function>
            </para>
          </listitem>
          <listitem>
            <para>
              <constant>XARVAR_PREP_FOR_HTML</constant>:
              <function>xarVarPrepHTMLDisplay(<varname>$value</varname>)</function>
            </para>
          </listitem>
          <listitem>
            <para>
              <constant>XARVAR_PREP_TRIM</constant>:
              <function>trim(<varname>$value</varname>)</function>
            </para>
          </listitem>
        </itemizedlist>
      </para>

      <section>
        <title>Pitfalls with xarVarFetch()</title>

        <para>No error given</para>

        <para>Note that if a default value is specified, even if it is '', the
        function will always succeed. If you need to catch validation errors
        and other errors, you must set the default value to NULL.</para>

        <para>Loops with 1 $variable name</para>

        <para>If you have built a loop with this function in it, you will
        notice that the value of the first found instance is returned every
        single call, even though you may be calling for different named $_POST
        or $_GET elements. To solve this either use a variable variablename,
        or use the flag XARVAR_DONT_REUSE.</para>
        
        <example>
          <title>Fetching input variables</title>
          <programlisting>
            // If this is in your template/xhtml
            &lt;input name="item1" value=1&gt;
            &lt;input name="item2" value=2&gt;

            xarVarFetch('item1', 'str::', $value, NULL ) //  $value= 1

            xarVarFetch('item2', 'str::', $value, NULL ) //  $value= 1 !!!
          </programlisting>
        </example>

        <para>It is currently not possible to discern between 'Not Found' and
        'Validation Failed', if you need to know use the validate function and
        $_POST/$_GET directly in the error handling part.</para>
      </section>

      <section>
        <title>Module variables</title>

        <para>Module variables can be set using
        xarModSetVar('module','modulevariable','initial value')</para>

        <para>Example: <programlisting>xarModSetVar('julian','startDayOfWeek','1');</programlisting></para>

        <para>These variables can be called later by xarModGetVar(module,
        variable)<programlisting>$cal_sdow = xarModGetVar('julian','startDayOfWeek'); </programlisting>Now,
        we can even make this a variable the admin can set. Then add to the
        modifyconfig.xd template the following code snippet: <programlisting>&lt;input type="text" name="startDayOfWeek" value="#xarModGetVar('julian','startDayOfWeek')#" size="2" /&gt;</programlisting>
        and in your redirect script (updateconfig.php in the example module)
        <programlisting>//check the input with
xarVarFetch if (!xarVarFetch('bold', 'checkbox', $bold, false, XARVAR_NOT_REQUIRED)) return;
// Set the Module Variable:
xarModSetVar('example', 'bold', $bold); </programlisting>This lets the admin
        that can enter modifyconfig.xd set the variable by typing in a number
        for the variable 'startDayOfWeek', or 'bold' as in the example.</para>
      </section>
    </section>

    <section>
      <title>User Variables</title>

      <para>A user variable is an entity identified by a name that stores a
      value owned by exactly one user. Xaraya offers two API functions to
      manipulate user variables, they are xarUserGetVar() and xarUserSetVar().
      The purpose of xarUserGetVar() is to allow read access to one user
      variable. In contrast to that, xarUserSetVar() allows write access to
      one user variable. The $name parameter is checked against metadata to
      make sure the variable is registered. Xaraya keeps some metadata about
      every user variable, so you cannot access the $name user variable if its
      metadata is not registered.</para>

      <para>A module can register a new user variable by providing its
      metadata only if it has the right permissions (permissions are checked
      by the registration function). Usually the registration process should
      take place at initialization time for a module that wants to use the
      $name user variable during its life cycle. Xaraya does not impose any
      restriction on the value of $name except for duplicate and reserved
      names.</para>

      <para>
        As of this writing, the list of reserved names consists of:
        <itemizedlist>
          <listitem><para><constant>uid</constant> The user id.</para></listitem>
          <listitem>
            <para><constant>name</constant> The user display name on the system.
            “Name” should be used in any case that you are displaying the user
            name, IE author fields, etc.</para>
          </listitem>
          <listitem>
            <para><constant>uname</constant> The user name is the system
            variable used to differentiate one user from another in string vice
            integer format. This variable should not be used to display
            information about the user for consistency and security
            reasons.</para>
          </listitem>
          <listitem>
            <para><constant>email</constant> The email address of the
            user.</para>
          </listitem>
          <listitem>
            <para><constant>status</constant> The status of the user (active,
            inactive, deleted etc).</para>
          </listitem>
          <listitem>
            <para><constant>auth_module</constant> The authentication module
            last used for this user.</para>
          </listitem>
        </itemizedlist>
      </para>

      <para>You are advised (even for performance reasons) to use the
      following naming convention: <programlisting>$name := $module_name . '_' .
      $real_name</programlisting></para>

      <para>To register the $name user variable you have to use the module API
      function register_user_var() exported by the Modules module.</para>

      <para>Here is an example: <programlisting>
        $module_name = 'MyModule';

        $variable_name = 'MaxLinesPerPage';

        $metadata['label'] = $module_name . '_' . $variable_name;

        $metadata['dtype'] = _UDCONST_INTEGER; //one of the values  defined for dynamic user data variable types

        $metadata['default'] = 20; $metadata['validation'] = 'num:&gt;=:10&amp;num:&lt;=:100';

        xarModAPILoad('Modules', 'admin');

        $result = xarModAPIFunc('Modules', 'admin','register_user_var', $metadata);

        if (!isset($result)) {
            // xarModAPIFunc() failed
        } elseif ($result == false) {
            // registration failed
        } else {
            // registration succeeded
        }
        </programlisting></para>

      <para>As you can see in this example, a descriptive array for the new
      user variable is created first, and later register_user_var is called
      with that array as parameter. Meaningful keys for the array are label,
      dtype, default and validation. The label field is mandatory; it
      specifies the user variable name as you'll refer later in
      xarUserGetVar() and xarUserSetVar() $name parameter. The dtype field is
      mandatory; it can take one of the following values: _UDCONST_STRING,
      _UDCONST_TEXT, _UDCONST_FLOAT, _UDCONST_INTEGER. You should obviously
      choose the right value for the data type that the new user variable
      would contain. The default field is optional; Used when the user has not
      yet set a value for the new user variable. The validation field is
      optional; refer to the next section to get an overview of variable
      validation. To unregister a user variable you have to call the
      unregister_user_var(), which is located in the users module admin API.
      You should call that API only at uninstallation time for your modules.
      Keep in mind that by calling unregister_user_var() all the existing
      values for that user variable will be deleted from user data. As
      described in this document, Xaraya offers support for module variables
      too. If you get confused from that, and cannot see the distinction
      between these different things, here is a little explanation. Module
      variables are system-wide variables, shared between each module user,
      like configuration variables. No particular user owns them, and even if
      they do they are protected by permissions for write access, they are
      typically administrative-side variables. You are encouraged to use them
      when you have a need to give administrators the possibility to choose
      some behaviors of your module. However, when those behaviors are related
      to user preferences you should avoid using module variables and register
      a new user variable to be used in your code.</para>

      <para>As an example, you can consider the above code listing, where a
      new user variable is registered to allow every single module user to
      choose his own MaxLinePerPage setting. Now it is reasonable to have
      selected this choice, but here we could have chosen a unique shared
      module var as well. On the other hand, you do not have this kind of
      freedom, for example consider the authldap module in some cases. It
      needs to access a LDAP server, so it needs a variable that contains the
      LDAP server hostname. Obviously this variable should be a module
      variable, and access to it should be granted only to administrators with
      the right permissions. We invite you to ponder this issue for a while
      before you settle on module vars or user vars.</para>

      <para>Setting xarUserVars</para>

      <para>All user vars should be set from adding Dynamic Data on the roles
      module. This will give you the greatest benefit and will present the
      variables to all modules on the system.</para>
    </section>

    <section>
      <title>Error handling</title>

      <para>Xaraya is capable of error handling through a powerful exception
      handling system. Since the PHP language does not support language-level
      exceptions, Xaraya provides an artificial mechanism to deal with
      exceptions. Xaraya divides exceptions into two types: system exceptions
      and user exceptions. System exceptions are used by Xaraya API functions,
      but you can use them if it's meaningful in that such situation; for
      example consider the DATABASE_ERROR exception, you are strongly
      encouraged to use this exception when a database error occurs and not to
      use your own exception.</para>

      <para>As another example considers the BAD_PARAM exception, you should
      choose to use that exception in your module functions and API functions
      when passed parameters are wrong. Finally, system exceptions are well
      known exceptions for which Xaraya can undertake. Xaraya does not know
      particular actions like logging, emailing, or user exceptions, and since
      they are indistinguishable, Xaraya will treat them, as they were all the
      same thing.</para>

      <para>Another good point of distinction between system and user
      exceptions is the fact that you should not leave uncaught user
      exceptions as you can do for system exceptions. Hence, you should catch
      all user exceptions instead of throwing them back to Xaraya, this is
      because user exceptions are the same as soft exceptions, so you could be
      in the position of doing other actions and/or returning a properly
      formatted error message that will look better than the default Xaraya
      exception caught error message. However, it is not illegal to throw back
      user exceptions to Xaraya, so fell free to do that if it is the
      case.</para>

      <para>You should avoid catching system exceptions, except in particular
      cases. A system exception is a hard exception, this means that something
      very wrong happened and Xaraya should be notified. You can achieve this
      simply by throwing back system exceptions. In addition, there are
      particular circumstances in which you could and perhaps should catch
      system exceptions.</para>

      <para>For example consider the xarUserGetVar() API function: it raises a
      NO_PERMISSION system exception in the case you don't have right
      permission, however you weren't in the position to get access level for
      user variables, so it's perfectly acceptable here to catch this
      exception and go ahead when it's meaningful to do so.</para>

      <para>Now is the moment to explore how Xaraya permits you to deal with
      exceptions. Here we begin by exposing how to catch exceptions. When a
      function that potentially can raise exceptions, outcomes with a void
      value you MUST check if some exception was raised. You can do that by
      calling the xarExceptionMajor() function and comparing its return value
      with the <constant>XAR_NO_EXCEPTION</constant> constant. If they are different, you know that
      an exception has been raised.</para>

      <para>The xarExceptionMajor() return value can assume one of these
      values: <constant>XAR_NO_EXCEPTION</constant>, <constant>XAR_USER_EXCEPTION</constant>, <constant>XAR_SYSTEM_EXCEPTION</constant>. The
      value <constant>XAR_NO_EXCEPTION</constant> indicates that no exception was raised, and
      <constant>XAR_USER_EXCEPTION</constant> stands for user exception was raised and
      <constant>XAR_SYSTEM_EXCEPTION</constant> stands for system exception was raised.</para>

      <para>When you see that an exception was raised you have two options:
      throw it back or handle it. To throw back an exception you have only to
      return with a void value. To handle an exception you have to check for
      the exception type, id and value if one.</para>

      <para>Consider the following example:</para>

      <para><programlisting>
          $res = xarModFunc('MyModule', 'user','MyFunc');
          if (!isset($res) &amp;&amp; xarExceptionMajor() != XAR_NO_EXCEPTION) {
              // Got an exception if (xarExcepionMajor() == XAR_SYSTEM_EXCEPTION) { return; // throw back }

              // Got a user exception
              if (xarExceptionId() == 'MyException1') {
                  $value = xarExceptionValue();

                  $output-&gt;Text("Syntax error at line: ".$value-&gt;lineNumber);

              } elseif (xarExceptionId() == 'MyException2') {
                  /* Do something useful */
              } else { // MyException3
                  /* Do something useful */
              } // reset exception status

              // NOTE: it's of vital importance to call this function
              // before returning xarExceptionFree();

              return $output-&gt;GetOutput();
          }
        </programlisting></para>

      <para>To throw exception you use a unique function: xarExceptionSet().
      You simply call it by passing the exception major, id and value if one;
      and after this call, you return void.</para>

      <para>Consider the following example:</para>

      <para><programlisting>class MyException1
{
    var $lineNumber;
}
/* ... */
MyModule_user_MyFunc()
{
    /* ... */
    if ($syntax == false) { // Syntax error
        $exc = new MyException1;
        $exc-&gt;lineNumber = $line;
        xarExceptionSet(XAR_USER_EXCEPTION, 'MyException1', $exc);
        return;
    }
    /* ... */
    xarExceptionSet(XAR_USER_EXCEPTION, 'MyException2');
    /* ... */
    xarExceptionSet(XAR_USER_EXCEPTION, 'MyException3');
    /* ... */
    return true;
}</programlisting></para>

      <para>Note that no value is associated to MyException2 and MyException3,
      so there is no need to create a class for exception value. As you can
      see exception, handling is very powerful but also boring and tedious.
      However, you can always choose not to use user exceptions and always
      throw back system exceptions.</para>

      <para>Keep in mind that good error handling is not something that to
      leave for last. It should be part of the development process. Note that
      it is wrong not to check exception status after a call to a function
      that can potentially raise something. And note also that if you choose
      to handle one or more exceptions you MUST call xarExceptionFree() before
      exiting, otherwise the trust relationship on which the exception
      handling mechanism is based won't work and you will produce very bad
      things.</para>

      <para>An ulterior thing for those of you wanting to code an official
      Xaraya module: you MUST always check for possibly raised exceptions and
      not code with the thought that something will never happen; you MUST
      also raise DATABASE_ERROR in every function that does queries. To get a
      better understanding of exception handling functions you should refer to
      the Xaraya API Command Reference.</para>
    </section>

    <section>
      <title>Itemtypes</title>

      <para>Itemtypes definitions are crucial in Xaraya operations. Itemtypes
      are very important when ever your data is shared with either hooks or by
      other modules.</para>

      <para>Related functions</para>

      <para>-getitemtypes</para>

      <para>-getitemlinks</para>
    </section>

    <section>
      <title>Interaction with core classes</title>

      <para>The interaction with core functions, what to rely on and how to
      access these functions</para>
    </section>

    <section>
      <title>Multilanguage system</title>

      <para>Xaraya can be fully multilanguage. Make sure all your text strings
      are encapsulated with either <programlisting>xarML('YourMLString') </programlisting>in
      your functions or <programlisting>&lt;xar:mlstring&gt;YourMLString&lt;/xar:mlstring&gt;</programlisting>
      in the templates</para>
    </section>

    <section>
      <title>Variable preparations</title>

      <para><programlisting>xarVarPrepForDisplay(YourString);</programlisting></para>
    </section>

    <section>
      <title>Dynamic Data</title>

      <para>Properties</para>

      <para>Your own properties</para>
    </section>
  </chapter>

  <!-- Module architecture -->
  &xaraya_module_architecture;


  <chapter>
    <title>Xaraya Module Operations</title>

    <para>This chapter covers how modules interact with Xaraya. The
    information in this section is correct for the 1.0 release of Xaraya, for
    other releases please get the most recent copy of the Xaraya Module
    Developers Guide.</para>

    <section>
      <title>Locating Modules</title>

      <para>All Xaraya modules must be placed within their own subdirectory of
      the 'modules' directory to be recognized. Modules placed anywhere else
      within the file-system will not be located correctly.</para>
    </section>

    <section>
      <title>Working out Module Functionality</title>

      <para>A module might have administration or user functionality, or both.
      Xaraya works out which functionality each module has by looking for the
      files in 'xaradmin' or 'xaradminapi’ directories to confirm
      administration functionality, and in 'xaruser' or 'xaruserapi'
      directories to confirm user functionality. Lack of these directories
      results in Xaraya assuming that this specific module functionality does
      not exist.</para>
    </section>

    <section>
      <title>Initializing Modules</title>

      <para>Initialization of modules is accomplished through the
      modname_init() in the 'xarinit.php' file within the module's directory
      function. No other functions are called when the module is initialized.
      All initialisation routines should go into the init function.</para>
    </section>

    <section>
      <title>Activating/Deactivating Modules</title>

      <para>Activation and deactivation of modules is accomplished through
      field settings within the appropriate database table. Unlike earlier
      versions of Xaraya, no physical changes to the module directories are
      made to infer the activation status of the module.</para>
    </section>

    <section>
      <title>Upgrading your module</title>

      <para>Upgrading your module is important. The upgrade function is
      located in the xarinit.php and named yourmodule_upgrade(). This function
      takes the current versionnumber as 'oldversion' and uses a switch to
      look for the correct upgrade routines. Make sure you provide all
      necessary steps for each version to upgrade to the next version. Provide
      an empty upgrade step when there is nothing todo. This way, the upgrade
      function will stay consistent. The versionid is set in the
      xarversion.php file.</para>
    </section>

    <section>
      <title>Calling Module Functions</title>

      <para>Module functions are called through the xarModFunc() and
      xarModAPIFunc() functions. No direct calling of module functions is
      allowed, even from within the same module. Creating Module URLs Direct
      URLs to functions URLs for modules go through the 'index.php' entry
      point, and are defined by a number of parameters. The parameters that
      currently decide which particular module function to call are as
      follows: module The name of the module. This corresponds to the
      well-known name of the module, which can be found through the modules
      administration interface type The type of the module function. This is
      currently either 'user' for user functions or 'admin' for administrative
      functions. func The name of the function itself. This is
      module-dependent. If any of these parameters are undefined within a URL
      Xaraya will apply defaults to them. Note that both the names of the
      parameters and their default values might change, and as such it is not
      recommended to create direct URLs for anything but to either go through
      the Xaraya main page or to use the xarModURL() function to generate URLs
      that will always be internally consistent for any given version of
      Xaraya. You can also extend the xarModUrl call by adding a parameter
      call to the function in the form of an array. <programlisting><function>xarModURL('<parameter>module</parameter>', 'type', 'function', array('foo' =&gt; $bar))</function></programlisting>
      will create the input parameter of 'foo' having the value of
      $bar.</para>

      <section>
        <title>Function calls</title>

        <para>Another way of accessing the functionality of other modules is
        by calling their functions directly with the xarModFunc() function.
        Doing this allows a number of advantages over hooks, but also a number
        of disadvantages. In general, calling functions directly is more
        flexible as the module developer understands exactly which functions
        they are calling and can pass additional arguments to the function to
        customize its abilities. The disadvantages are that the module named
        in the function call needs to be installed and active on the system
        for the calls to work, and if this is replace by a different module
        providing similar functionality it will not work correctly.</para>

        <para>Using direct function calls to other modules is fine within a
        module, but the developer should consider the implications of this on
        systems that might not have the modules that they are using installed.
        Also, even if direct function calls are used then the module developer
        should still call hooks at the appropriate places in the code to allow
        for other extended functionality to be added to the module.</para>

        <para>An example of where direct function calls might be used within
        the Example module would be if the module developer wanted users to be
        able to rate various aspects of the picture displayed such as 'use of
        color' and 'originality'. In this case, a simple hook would not be
        able to accommodate this requirement, so the developer would instead
        make explicit calls to the 'Ratings' utility module to display a
        number of separate ratings, each with its own identifier. The hook
        call would still be made, which might also add a rating to the
        picture, but in this case, the value could be considered as the
        overall rating for the picture rather than that just for a specific
        part.</para>
      </section>
    </section>

  </chapter>

  <!-- Hooks -->
  &understanding_hooks;


  <chapter>
    <title>Writing your module</title>

    <para>This Chapter can be the reference to how to setup your module
    design</para>

    <section>
      <title>Before Starting Your Module</title>

      <para>There are a number of steps to follow before you can start
      building your module.</para>

      <para>Choosing a Name for Your Module</para>

      <para>Choosing a name for your module is important, as this is the main
      way that your module will be known throughout the Xaraya community. The
      name should relate to the functionality that the module provides, but
      also be specific enough to be able to discern it from separate modules
      that might offer similar functionality. Module names are case-sensitive.
      All modules names are lower-case only.</para>

      <para>Decide on the Type of Your Module</para>

      <para>There are two broad types of module available in Xaraya. Item
      modules are modules, which contain their own content and operate on that
      content, whereas utility modules are modules, which contain additional
      information or functionality for the content of other modules. Examples
      of item modules are news, FAQ, and download. Examples of utility modules
      are comments, ratings, and global index. Either utility modules work in
      the same way as item modules, or they can operate with hooks, which
      allow module functions to be acted upon without being explicitly called
      by other modules. Hooks are used for items that are not part of a piece
      of content but directly related to it.</para>

      <para>Register Your Module Name</para>

      <para>Registering your module is not compulsory, but it is a very good
      idea. By registering your module, you can ensure that no other official
      Xaraya module will take the name that you have chosen for your module.
      Two modules with the same name will not operate correctly on a single
      Xaraya site, so it is beneficial to both yourself and the Xaraya
      community in general to have a unique name. You may register your module
      via the release module on <ulink url="???">http://www.xaraya.com/
      </ulink></para>

      <para>Obtain a Copy of the Xaraya API Reference Guide</para>

      <para>The Xaraya API Reference Guide has been moved to the PHP-Doc style
      of documentation. No separate entry will be created for the API guide.
      Please reference http://docs.xaraya.com/index.php/documentation/c80/ for
      more information.</para>

      <para>Read the Notes on Developing Modules Section</para>

      <para>The section entitled 'Notes on Developing Modules' includes a lot
      of miscellaneous information that does not fit in other sections of this
      document. It should be read fully before any attempt to design or
      develop a module is started.</para>

      <para>Understand the Following Areas</para>

      <para>Difference between GUI and Operational Functions</para>

      <para>Understanding the difference between GUI and operational functions
      is critical when building a good module. Proper separation of these
      functions will allow other modules to be able to access the
      functionality of your module and incorporate it into their modules. It
      will also allow methods of access apart from those that the standard
      web-based Xaraya system.</para>

      <para>Difference between User and Administrative Functions</para>

      <para>Understanding the difference between user and administrative
      functions is very important when building a good module. The separation
      of these types of actions allows for the Xaraya Security Model The
      Xaraya security model is a very important area to understand before
      coding a module. Developers should understand which parts of their
      module need protected, and exactly how this is accomplished. The entire
      Xaraya security model is beyond the scope of this document. The Security
      System RFC30 is located at
      http://docs.xaraya.com//docs/rfcs/rfc0030.html</para>

      <para>Function Return Codes</para>

      <para>Every well-defined module function must return the appropriate
      return codes. Return codes are the main way in which a module
      communicates with the Xaraya core, and as such, it is vital that the
      correct return codes are used. The following return codes should be used
      when returning control to the Xaraya core from any module
      function:</para>

      <para>string</para>

      <para>Returning a text string implies that the modules function has
      finished its work and has output to be displayed in the appropriate
      place on the Xaraya web page. Xaraya will take the returned output and
      display it as appropriate. Note that all output from modules is
      displayed verbatim, with no escaping of HTML characters. This is to
      allow for formatted output from the module functions.</para>

      <para>true</para>

      <para>Returning boolean true implies that the module function has
      finished its work and set up an appropriate redirect to send the user to
      a page that will have display output. The Xaraya core will take no
      further action as far as this module is concerned.</para>

      <para>false</para>

      <para>Returning boolean false implies that the module function has
      finished its work but not set up an appropriate redirect to send the
      user to a page that will have display output. The Xaraya core will set
      an appropriate redirect for this module. Note that none of these
      functions carries any information about the success or failure of the
      attempted operation that the module function was undertaking.</para>

      <para>array</para>

      <para>The array can contain the parameters that you need to return to
      the Xaraya core</para>

      <para>Where Modules Fit in Xaraya</para>

      <para>Modules cover two separate areas of Xaraya. The first is
      administration of core functions, (e.g. users, permissions), and the
      second is extension of system functionality (e.g. downloads, web links).
      As each of these areas is not core this implies two things. First is
      that no module is actually required - the Xaraya system would work
      without anything in its modules directory, although its functionality
      would be severely limited and there would be no configuration options
      available. Second, is that modules should not remove any core
      functionality when installed, in operation, or removed.</para>
    </section>

    <!-- Here was an explanation on the checklist for modules -->
  </chapter>

  <chapter>
    <title>Notes in Developing Modules</title>

    <para>xarAPI is the Xaraya Application Programming Interface, a way for
    modules to interact with the Xaraya core without needing to access tables
    and internal structures directly. The API also allows for the underlying
    implementation details of Xaraya to be hidden from developer so that they
    can write modules in a standard fashion and not worry about what might
    change under the hood. This is very important for a system such as Xaraya,
    which has undergone, and continues to undergo, radical changes in the core
    design to allow it to be faster, more secure, and more flexible. xarAPI is
    the only supported way of accessing core information. Module developers
    must use these methods of obtaining information from the Xaraya core
    system; failure to do so will very likely result in their module not
    working when the next version of Xaraya is released.</para>

    <section>
      <title>Security</title>

      <para>Security is a very important part of Xaraya. All modules should
      subscribe to the Xaraya Security model to ensure that they operate
      correctly within all environments. For full information on security
      refer to the Xaraya Security Model documentation, however the main
      points as regards modules are covered briefly below. Variable Handling
      All variables that come in to or go out of Xaraya should be handled by
      the relevant xarVar*() functions to ensure that they are safe. Failure
      to do this could result in opening security holes at the web,
      file-system, display, or the database layers. Full information on these
      functions is in the Xaraya API Guide, and examples of their use are
      shown throughout the example module. It can be assumed that any
      variables passed to functions in the Xaraya API will be handled
      correctly, and as such these variables do not need to be prepared with
      the xarVar*() functions.</para>
    </section>

    <section>
      <title>Authorization</title>

      <para>All items displayed for users and actions carried out by
      administrators must be authorized through use of the xarSecAuthAction()
      function. This function underlies the entire Xaraya permissions system
      and as such must be used wherever an access check is required.</para>
    </section>

    <section>
      <title>Reserved Variable Names</title>

      <para>
        Xaraya has a number of variables, which are reserved. These
        variables are not be used within modules as they can conflict with the
        Xaraya core and cause unpredictable results. The current lists of
        variables, which are reserved, are as follows:
        <itemizedlist>
          <listitem>
            <para><varname>file</varname>: the file to open</para>
          </listitem>
          <listitem>
            <para>
              <varname>func</varname>: 
              In use for Function, the function being called
            </para>
          </listitem>
          <listitem>
            <para><varname>loadedmod</varname>:
            The module that is loaded. Mainly in use by the core module
            'roles'
            </para>
          </listitem>
          <listitem>
            <para><varname>module</varname>:
            The module that is being called
            </para>
          </listitem>
          <listitem><para><varname>name</varname></para></listitem>
          <listitem><para><varname>op</varname></para></listitem>
          <listitem><para><varname>pagerstart</varname></para></listitem>
          <listitem><para><varname>pagertotal</varname></para></listitem>
          <listitem>
            <para><varname>type</varname>:
            Either user or admin, type of function to call
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>In addition, all one-letter variables are reserved.</para>
    </section>

    <section>
      <title>Page Path</title>

      <para>All input from web pages goes through a two-stage process. The
      first part is displaying the information entered in a form, and the
      second is obtaining that information and passing it on to the module
      API. In addition to the visible information, there are often a number of
      hidden items of information in the first page that is used in the second
      page. To ensure that any attempt to add, delete, or change information
      in the Xaraya system goes through the full two-stage method of gathering
      and processing the information the two functions xarSecGenAuthKey() and
      xarSecConfirmAuthKey() must be used in the appropriate places. The
      Example module in the standard Xaraya distribution contains a number of
      functions that use these API calls, and note where they are used so that
      developed modules will have the same level of protection against
      fraudulent administrator requests.</para>
    </section>

    <section>
      <title>Output</title>

      <para>All output generated by module functions must be returned to the
      Xaraya core. No output of any type pushed directly from the module; this
      is not supported and will break in future versions of Xaraya.</para>
    </section>

    <section>
      <title>Using Object Oriented Code</title>

      <para>Modules written as classes is allowed, however the API as
      described in the rest of this document must still be adhered to. The
      simplest way of doing this is to use compatibility functions, for
      example: 
      <programlisting>
        function mymod_user_main() {
          // Instantiate
          $obj = new myClass();
          // Call relevant method and return output return
          $obj-&gt;usermain();
        }
      </programlisting></para>
    </section>
  </chapter>

  <!-- Create module part came roughly from here -->
  &create_your_module;
  
  <chapter>
    <title>All others</title>

    <para>Dumping all other remarks for the moment</para>

    <section>
      <title>Recommendations</title>

      <para>If you are new to Xaraya, it is highly recommended that you
      familiarize yourself with Xaraya by reading the Xaraya Installation and
      Getting Started Guide. The guide is currently available via the monotone
      repository located on the mt.xaraya.com website. As a side note, the
      guide is currently a work in progress, once completed the guide will be
      available by means that are more accessible.</para>

      <para>Xaraya News Groups: The following lists of news groups are
      available via news.xaraya.com. These news groups are also available via
      your web browser at the following Web site:
      http://www.xaraya.com</para>
      <itemizedlist>
        <listitem><para>Ddf.public - DDF Public List</para></listitem>
        <listitem><para>Xaraya.announce - Xaraya Announcements List</para></listitem>
        <listitem><para>Xaraya.devel - Xaraya Member List</para></listitem>
        <listitem><para>Xaraya.mt-notices - Pushes to the monotone repository, see  mt.xaraya.com</para></listitem>
        <listitem><para>Xaraya.documentation - Xaraya Documentation List</para></listitem>
        <listitem><para>Xaraya.bugs - Xaraya Bugs List</para></listitem>
        <listitem><para>Xaraya.ui - Xaraya User Interface List</para></listitem>
        <listitem><para>Xaraya.knowledge-base - Xaraya Knowledge Base List</para></listitem>
        <listitem><para>Xaraya.marketing - Xaraya Marketing</para></listitem>
        <listitem><para>Xaraya.patches - Xaraya Patches</para></listitem>
        <listitem><para>Xaraya.qa - Xaraya Quality Assurance</para></listitem>
        <listitem><para>Xaraya.user - Xaraya User Discussion List</para></listitem>
        <listitem><para>Xaraya.user-arabic - Xaraya Arabic User Discussion List</para></listitem>
        <listitem><para>Xaraya.user.chinese - Xaraya Chinese User List</para></listitem>
        <listitem><para>Xaraya.user.danish - Xaraya Danish User Discussion List</para></listitem>
        <listitem><para>Xaraya.user.dutch - Xaraya Dutch User Discussion List</para></listitem>
        <listitem><para>Xaraya.user.french - Xaraya French User Discussion List</para></listitem>
        <listitem><para>Xaraya.user.german - Xaraya German User Discussion List</para></listitem>
        <listitem><para>Xaraya.user.greek - Xaraya Greek User Discussion List</para></listitem>
        <listitem><para>Xaraya.users.hungarian - Xaraya Hungarian User Discussion List</para></listitem>
        <listitem><para>Xaraya.user.italian - Xaraya Italian User Discussion List</para></listitem>
        <listitem><para>Xaraya.user.polish - Xaraya Polish User Discussion List</para></listitem>
        <listitem><para>Xaraya.user.portuguese - Xaraya Portuguese User Discussion List</para></listitem>
        <listitem><para>Xaraya.user.russian - Xaraya Russian User Discussion List</para></listitem>
        <listitem><para>Xaraya.user.spanish - Xaraya Spanish User Discussion List</para></listitem>
      </itemizedlist>
    </section>
  </chapter>

  <!-- Index -->
  <index/>

  <!-- Bibliography -->
  &bibliography;
  
  <!-- Glossary -->
  &glossary;
</book>