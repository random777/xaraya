<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xsl"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<!-- <?rfc private='my private memo'?>  Produce a private memo rather than a Xaraya-standard -->
<?rfc toc='yes'?>
<rfc number="0014" category="info">
	<front>
		<title>Modular Authentication System</title>
		<author initials="M." surname="Canini" fullname="Marco Canini">
			<organization>Xaraya Development Group</organization>
			<address>
				<email>unknown</email>
				<uri>http://www.xaraya.com</uri>
			</address>
		</author>
		<date month="March" year="2002"/>
		<!-- The abstract summarizes in one or two paragraphs the content of the RFC -->
		<abstract>
			<t>The contents of this RFC contain the literal content of the old plain
	text version of RFC-0014</t>
			<t>When time is a less scarcer good, someone might convert the plain text
	into structured XML so we can benefit from it.
      </t>
		</abstract>
	</front>
	<!-- The middle section is used for the actual content of the RFC -->
	<middle>
		<!-- One content section is mandatory -->
		<section title="Introduction ">
			<t>
			Integration of older systems with new ones is a crucial point for success of systems, especially in the internet era. In main situations we can find heterogeneous services that can't cooperate because of their different authentication methods, and often implemented solutions are only wrappers or frontends to existing systems; in no way a definitive and universal solution. However in these years it's common practice to rely on well defined interfaces or portable libraries for getting a flexible and modular authentication system. To ensure Xaraya will be a high quality CMS we have to modularise authentication of users. This is definitely the purpose of MAS (Modular Authentication System).
			</t>
		</section>
		<section title="Modifications to current authentication API">
			<t>
			Currently the only official way to authorize user login is done by a set of functions in the Xaraya API. The default behavior of Xaraya will be to keep all registered users in the database. That is the current implementation. Modifications that will occure are: 
<list>
	<t>Migration of current authentication code in an authentication module.</t>
	<t>Reimplementation of user related API.</t>
	<t>Reimplementation of authorization info gathering function. Notwithstanding the introduction of a decentralised users database, to avoid user IDs duplications and espacially user data limitations, Xaraya will keep an entry for every user in the main database.</t>
</list>
 			</t>
		</section>
		<section title="Authentication Modules">
			<t>
			The main idea is to use Xaraya modules API for implementing authentication modules. With the advent of Dynamic User Data, Xaraya will keep in the main database the part of user data that can't be handled by authentication module. A generic authentication module could override the user data present in database with other existing data (Think to LDAP authentication where many data already exists). The word override has to be intended as follow: premising that at current time the static users table coexists with the Dynamic User Data, if an authentication module can provide user data from other sources, the value stored in database will be ignored (overridden) whether it exists (has to in static table context) or not (optional user property in Dynamic User Data). The authentication module could implement an interface to create new users. The authentication module could implement an interface to delete users. The authentication module could override the permissions fetched from the database if it implements another interface.
			</t>
			<section title="Module Interfaces">
				<t>
			     A generic authentication module must implement at least the Authentication interface. Other interfaces extend the exported module API and add new feautures to this module. Incarnation of interfaces is done by defining and implementing one or more module API functions (If you can't understand what is a module API function you're strongly encouraged to read the xarMDG documentation before proceding). The name of one authentication module API function, for its first part, is submitted to module API naming rules. The rest of the name is an underscore plus the interface method name. In this section are described all authentication interfaces currently supported by Xaraya.
			     </t>
				<section title="Interface Authentication">
					<section title="Definition ">
						<t>
							<artwork>
			              interface Authentication { 
    boolean authenticate_user($user_name, $user_password);
    boolean has_capability($capability);
} 
			              </artwork>
						</t>
					</section>
					<section title="Incarnation">
						<t>
			              A generic authentication module ('authgen') MUST incarnate at least this interface. The incarnation for this interface is done by declaring and implementing the following methods:
</t>
<t>
function authgen_userapi_authenticate_user($args) 
</t>
<t>
<artwork>  
This function will receive the following parameters:
  $args?'uname': user name
  $args?'pass': user password
  </artwork>
</t>
<t>
  This function MUST return a valid system user id IF and ONLY IF the user credentials are considered valid (the user is authenticated sucessfully) or _XARAUTH_FAILED for invalid credentials or false for bad parameters.
  Here is important to explain what a valid system user id is.
  Xaraya keeps a reference to all system users notwithstanding they're authenticated by different authentication modules.
  The section 5. User IDs mapping explains how to return a valid system user id.
</t>
<t>
function authgen_userapi_has_capability($args) 
  This function will receive the following parameters:
</t>
<t>
<artwork>  $args?'capability': the required capability, it's an identifier for another interface
                       possible values are: _XARAUTH_USER_DATA_HANDLER
                                            _XARAUTH_PERMISSIONS_OVERRIDER
                                            _XARAUTH_USER_CREATEABLE
                                            _XARAUTH_USER_DELETEABLE
                                            _XARAUTH_USER_ENUMERABLE
</artwork>
  </t>
<t>
This function MUST return true IF and ONLY IF the authentication module for wich it's written supports the required capability, false otherwise
			              </t>
					</section>
				</section>
				<section title=" Interface ?DynamicUserDataHandler_Authentication">
					<section title="Definition">
						<t>
						<artwork>			              interface ?DynamicUserDataHandler_Authentication extends Authentication { 
    boolean is_valid_variable($variable_name);
    array get_user_variables($user_id);
    string get_user_variable($user_id, $variable_name, $property_id, $property_dtype);
    boolean set_user_variable($user_id, $variable_name, $variable_value, $property_id, $property_dtype);
} 
</artwork>
			              </t>
					</section>
					<section title="Incarnation ">
						<t>
			              The incarnation for this interface is done by declaring and implementing the following methods: 
</t>
<t>
function authgen_userapi_is_valid_variable($args) 
</t>
<t>
<artwork>
  This function will receive the following parameters:
  $args?'name': variable name
  </artwork>
</t>
<t>
  This function MUST return true IF and ONLY IF the authentication module can provide read and write operations for that variable, false otherwise.
</t>
<t>
function authgen_userapi_get_user_variables($args) 
</t>
<t>
<artwork>
  This function will receive the following parameters:
  $args?'uid': user id
  </artwork>
</t>
<t>
<artwork>  This function MUST return all user variables handled by the authentication module as an associative array of pairs &lt;variable_name, variable_value&gt;, or false if it fails (remeber to set the errmsg session variable).
</artwork>
</t>
<t>
function authgen_userapi_get_user_variable($args) 
</t>
<t>
<artwork>
  This function will receive the following parameters:
  $args?'uid': user id
  $args?'name': variable name
  $args?'prop_id': variable id in user_property table (probably you can get rid of that)
  $args?'prop_dtype': variable type as defined by Dynamic User Data types
  </artwork>
</t>
<t>
  This function MUST return the value of required user variable handled by the authentication module or false when this variable doesn't exist for that user or when it fails to fetch variable value (remeber to set the errmsg session variable).
</t>
<t>
function authgen_userapi_set_user_variable($args) 
</t>
<t>
<artwork>
  This function will receive the following parameters:
  $args?'uid': user id
  $args?'name': variable name
  $args?'value': new value to set to
  $args?'prop_id': variable id in user_property table (probably you can get rid of that)
  $args?'prop_dtype': variable type as defined by Dynamic User Data types
  </artwork>
</t>
<t>
  This function MUST return true if the oparation was concluded with success, false when it fails in the set operation or for other errors (eg: Bad params, No such connection to backend, ...).
			              </t>
					</section>
				</section>
				<section title=" Interface ?PermissionsOverrider_Authentication ">
					<section title="Definition ">
						<t>
						<artwork>				interface ?PermissionsOverrider_Authentication extends Authentication { 
    array get_authorization_info($user_id);
} 
</artwork>
				</t>
					</section>
					<section title="Incarnation ">
						<t>
				TODO 
				</t>
					</section>
				</section>
				<section title="Interface ?UserEnumerable_Authentication">
					<section title="Definition ">
						<t>
						<artwork>
				interface ?UserEnumerable_Authentication extends Authentication { 
    array get_all_users();
    array get_user($user_id);
} 
</artwork>
				</t>
					</section>
					<section title="Incarnation ">
						<t>
				TODO
				</t>
					</section>
				</section>
				<section title=" Interface ?UserCreateable_Authentication">
					<section title="Definition ">
						<t><artwork>
				interface ?UserCreateable_Authentication extends Authentication { 
    boolean create_user($user_data);
}
 </artwork>
				</t>
					</section>
					<section title="Incarnation ">
						<t>
				TODO 
				</t>
					</section>
				</section>
				<section title=" Interface ?UserDeleteable_Authentication ">
					<section title="Definition ">
						<t>
						<artwork>
				interface ?UserDeleteable_Authentication extends Authentication { 
    boolean delete_user($user_id);
} 
</artwork>
				</t>
					</section>
					<section title="Incarnation ">
						<t>
				TODO
				</t>
					</section>
				</section>
			</section>
			<section title="Naming conventions">
				<t>
			     All authentication modules must respect the following naming conventions: 
			     <list>
					<t>Module name MUST start with "Auth".</t>
					<t>Module directory MUST be all in lowercase and MUST begin with "auth". </t>
					<t>Module name SHOULD reflect as best as possible the authentication mechanism on wich it's based.</t>
			     </list>
			     </t>
			</section>
		</section>
		<section title="Authentication intersection">
			<t>
		      The new authentication system will permit to use more than one authentication module. All modified User API will communicate with the correct authentication module.
			</t>
		</section>
		<section title="User IDs mapping">
			<t>
		      The UserIDs module will be created to handle UIDs inconsistencies. This is a utility module for authentication modules. Its API permits to easily find correspondencies between different system UIDs. Basically it will use the database to store all mappings.
			</t>
		</section>
		<section title="Changelog ">
			<t>
			 0.9 (April 27, 2002)
</t>
<t>
   Cleaned the architecture, moved most of complexity to core system.
</t>
<t>
   Added Incarnation section to explain the obscure incarnation thing.
</t>
<t>
   Added a naming convention.
</t>
<t>
 0.12 (April 13, 2002)
</t>
<t>
   Added has_capabilty method to Authentication interface.
</t>
<t>
      Its purpose is to communicate to the core whether an auth module supports an interface.
</t>
<t>
   Added ?DeleteableUserData_Authentication for a better fine-grained control on user variables.
</t>
<t>
   Renamed ?PermissionOverrider_Authentication to ?PermissionsOverrider_Authentication.
</t>
<t>
 0.1 (March 28, 2002)
</t>
<t>
   Corrected ?ReadableUserData_Authentication and ?WriteableUserData_Authentication interfaces.
</t>
<t>
   Better description of user data override mechanism (I hope).
</t>
<t>
   Added Naming conventions section.
</t>
<t>
   RFC number set to 14.
</t>
<t>
   Removed some typos (Thanks to Gregor).
</t>
<t>
   Rearranged document layout (Thanks to Gregor).
</t>
<t>
 pre-0.1 (March 27, 2002)
</t>
<t>
   Initial Version by Marco Canini &lt;marco.canini@postnuke.com&gt;
			</t>
		</section>
	</middle>
</rfc>
